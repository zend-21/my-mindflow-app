// src/App.jsx

import React, { useState, useEffect, useRef } from 'react';
import styled, { keyframes, css } from 'styled-components';
import { GlobalStyle } from './styles.js';
import { GoogleLogin } from '@react-oauth/google';
import { jwtDecode } from 'jwt-decode';
import { GoogleAuthProvider, signInWithCredential, signOut } from 'firebase/auth';
import { doc, getDoc, setDoc, updateDoc } from 'firebase/firestore';
import { auth, db } from './firebase/config';
import { initializeGapiClient, setAccessToken, syncToGoogleDrive, loadFromGoogleDrive, loadProfilePictureFromGoogleDrive, syncProfilePictureToGoogleDrive } from './utils/googleDriveSync';
import { backupToGoogleDrive } from './utils/googleDriveBackup';
import { DndContext, closestCenter, useSensor, useSensors, MouseSensor, TouchSensor } from '@dnd-kit/core';
import { SortableContext, useSortable, arrayMove, verticalListSortingStrategy } from '@dnd-kit/sortable';
import { CSS } from '@dnd-kit/utilities';
import { useLocalStorage } from './hooks/useLocalStorage';
import { exportData, importData } from './utils/dataManager';
import { format } from 'date-fns';
import { ko } from 'date-fns/locale';
import useAlarmManager from './hooks/useAlarmManager';
import { getRandomStealthPhrase } from './utils/stealthPhrases';
// í•˜ìœ„ ì»´í¬ë„ŒíŠ¸ë“¤
import Header from './components/Header.jsx';
import StatsGrid from './components/StatsGrid.jsx';
import QuickActions from './components/QuickActions.jsx';
import RecentActivity from './components/RecentActivity.jsx';
import BottomNav from './components/BottomNav.jsx';
import FloatingButton from './components/FloatingButton.jsx';
import SideMenu from './components/SideMenu.jsx';
import SearchModal from './components/SearchModal.jsx';
import MemoPage from './components/MemoPage.jsx';
import MemoDetailModal from './components/MemoDetailModal.jsx';
import NewMemoModal from './components/NewMemoModal.jsx';
import ConfirmationModal from './components/ConfirmationModal.jsx';
import ConfirmModal from './components/ConfirmModal.jsx';
import Calendar from './modules/calendar/Calendar.jsx';
import CalendarEditorModal from './modules/calendar/CalendarEditorModal.jsx';
import AlarmModal from './modules/calendar/AlarmModal.jsx';
import AlarmNotification from './modules/calendar/AlarmNotification.jsx';
import DateSelectorModal from './modules/calendar/DateSelectorModal.jsx';
import LoginModal from './components/LoginModal.jsx';
import FortuneFlow from './components/FortuneFlow.jsx';
import ProfilePage from './components/ProfilePage.jsx';
import Timer from './components/Timer.jsx';
import MacroModal from './components/MacroModal.jsx';
import { TrashProvider } from './contexts/TrashContext';
import TrashPage from './components/TrashPage.jsx';
import AppContent from './components/AppContent.jsx';
import SecretPage from './components/secret/SecretPage.jsx';
import MessagingHub from './components/messaging/MessagingHub.jsx';
import AdBanner from './components/messaging/AdBanner.jsx';
import ChatRoom from './components/messaging/ChatRoom.jsx';
import AppRouter from './components/AppRouter.jsx';
import './utils/createWorkspaceManually'; // ì›Œí¬ìŠ¤í˜ì´ìŠ¤ ìˆ˜ë™ ìƒì„± ìœ í‹¸ë¦¬í‹°
import { createWorkspace, checkWorkspaceExists } from './services/workspaceService'; // ìë™ ì›Œí¬ìŠ¤í˜ì´ìŠ¤ ìƒì„±
import CollaborationRoom from './components/collaboration/CollaborationRoom.jsx'; // í˜‘ì—…ë°© ì»´í¬ë„ŒíŠ¸

// â˜…â˜…â˜… í† ìŠ¤íŠ¸ ë©”ì‹œì§€ ìŠ¤íƒ€ì¼ â˜…â˜…â˜…
const fadeIn = keyframes`
    from { opacity: 0; }
    to { opacity: 1; }
`;

const MainContent = styled.main`
  padding-top: 80px; /* í—¤ë” ë†’ì´ë§Œí¼ íŒ¨ë”© ì¶”ê°€ */
  display: flex;
  justify-content: center;
  align-items: center;
  height: 100vh;
`;

const slideUp = keyframes`
    from { transform: translateY(20px); opacity: 0; }
    to { transform: translateY(0); opacity: 1; }
`;

const PullToSyncIndicator = styled.div`
  position: fixed;
  top: 75px; /* 5px ìœ„ë¡œ ì´ë™ */
  left: 50%;
  transform: translateX(-50%);
  display: flex;
  align-items: center;
  gap: 8px;
  color: #818181ff;
  font-size: 14px;
  animation: ${fadeIn} 0.3s ease-out;
  z-index: 5000;
`;

const PullGuideMessage = styled.div`
  position: fixed;
  top: 75px; /* 5px ì•„ë˜ë¡œ ì´ë™ (70px â†’ 75px) */
  left: 50%;
  transform: translateX(-50%);
  background: rgba(102, 126, 234, 0.9);
  color: white;
  padding: 8px 16px;
  border-radius: 20px;
  font-size: 13px;
  font-weight: 500;
  z-index: 5000;
  animation: ${fadeIn} 0.2s ease-out;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
`;
const SyncingIndicator = styled.div`
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    z-index: 10000; /* ëª¨ë“  UI ìœ„ì— í‘œì‹œ */
    width: 60px;
    height: 60px;
    border: 6px solid rgba(0, 0, 0, 0.1);
    border-radius: 50%;
    border-top-color: #5c67f2;
    animation: ${keyframes`
        to { transform: rotate(360deg); }
    `} 1s linear infinite;
`;

const SyncSpinner = styled.div`
  width: 16px;
  height: 16px;
  border: 2px solid #a0aec0;
  border-top: 2px solid transparent;
  border-radius: 50%;
  animation: spin 1s linear infinite;

  @keyframes spin {
    from { transform: rotate(0deg); }
    to { transform: rotate(360deg); }
  }
`;

const ToastOverlay = styled.div`
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 12000;
  background: rgba(0, 0, 0, 0.2);
  animation: ${fadeIn} 0.2s ease-out;
`;

const ToastBox = styled.div`
  background: rgba(0, 0, 0, 0.9); /* ë” ì–´ë‘¡ê²Œ */
  color: white;
  padding: 24px 32px; /* ë” í¬ê²Œ */
  border-radius: 12px;
  font-size: 18px; /* ë” í¬ê²Œ */
  font-weight: 600; /* êµµê²Œ */
  box-shadow: 0 8px 20px rgba(0, 0, 0, 0.4); /* ë” ì§„í•œ ê·¸ë¦¼ì */
  animation: ${slideUp} 0.3s cubic-bezier(0.2, 0, 0, 1);
  text-align: center;
  min-width: 200px; /* ìµœì†Œ ë„ˆë¹„ */
  z-index: 12001; /* z-index ë” ë†’ê²Œ */
`;

const Screen = styled.div`
    height: 100vh;
    width: 100%;
    max-width: 450px;
    margin: 0 auto;

    background: linear-gradient(180deg, #1a1a1a 0%, #0f0f0f 100%);
    position: relative;
    display: flex;
    flex-direction: column;
    overflow-x: hidden;
    overflow-y: hidden;  /* â† visibleì—ì„œ hiddenìœ¼ë¡œ ë³€ê²½ */
    overscroll-behavior: none;
    overscroll-behavior-y: contain;
    
    -webkit-tap-highlight-color: transparent;
    user-select: none;
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;

    /* â˜…â˜…â˜… íƒœë¸”ë¦¿ í™”ë©´ â˜…â˜…â˜… */
    @media (min-width: 768px) {
        max-width: 480px; /* â—€â—€â—€ ì±…ì¥ì˜ í­ì„ ë„“í™ë‹ˆë‹¤ */
        box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);

        ${props => props.$layoutView === 'grid' && `
            grid-template-columns: repeat(2, 1fr);
            gap: 16px;
        `}
    }

    /* â˜…â˜…â˜… ë°ìŠ¤í¬íƒ‘ í™”ë©´ â˜…â˜…â˜… */
    @media (min-width: 1024px) {
        max-width: 530px; /* â—€â—€â—€ ì±…ì¥ì˜ í­ì„ ë” ë„“í™ë‹ˆë‹¤ */

        ${props => props.$layoutView === 'grid' && `
            grid-template-columns: repeat(3, 1fr);
            gap: 20px;
        `}
    }
    
    /* â˜…â˜…â˜… ë” í° ë°ìŠ¤í¬íƒ‘ í™”ë©´ â˜…â˜…â˜… */
    @media (min-width: 1440px) {
        max-width: 580px; /* â—€â—€â—€ ì±…ì¥ì˜ í­ì„ ìµœëŒ€ë¡œ ë„“í™ë‹ˆë‹¤ */
        
        ${props => props.$layoutView === 'grid' && `
            grid-template-columns: repeat(3, 1fr);
            gap: 24px;
        `}
    }
    
    /* â˜…â˜…â˜… ë” í° ë°ìŠ¤í¬íƒ‘ í™”ë©´ â˜…â˜…â˜… */
    @media (min-width: 1900px) {
        max-width: 680px; /* â—€â—€â—€ ì±…ì¥ì˜ í­ì„ ìµœëŒ€ë¡œ ë„“í™ë‹ˆë‹¤ */
        
        ${props => props.$layoutView === 'grid' && `
            grid-template-columns: repeat(3, 1fr);
            gap: 24px;
        `}
    }
`;

const ContentArea = styled.div`
    flex: 1;
    padding-left: ${props => props.$isSecretTab ? '0' : '24px'};
    padding-right: ${props => props.$isSecretTab ? '0' : '24px'};
    padding-bottom: 80px;
    padding-top: ${props => props.$showHeader ? '90px' : '20px'};
    overflow-y: auto;
    position: relative;
    transition: padding-top 0.3s ease${props => props.$isDragging ? '' : ', transform 0.3s ease'};
    transform: translateY(${props => props.$pullDistance}px);
    will-change: transform;
    overscroll-behavior: none;
    touch-action: pan-y;
    background: ${props => props.$isSecretTab ? 'linear-gradient(180deg, #1a1d24 0%, #2a2d35 100%)' : '#1a1a1a'};
`;

const LoginScreen = styled.div`
    flex: 1;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    text-align: center;
    padding: 0 24px;
    h2 {
        font-size: 24px;
        color: #e0e0e0;
        margin-bottom: 10px;
    }
    p {
        font-size: 16px;
        color: #b0b0b0;
        margin-bottom: 30px;
    }
`;

const LoadingScreen = styled.div`
    width: 100%;
    height: 100%;
    display: flex;
    justify-content: center;
    align-items: center;
    font-size: 20px;
    color: #b0b0b0;
`;

const LoginButton = styled.button`
    background-color: #4a90e2;
    color: white;
    border: none;
    padding: 12px 24px;
    border-radius: 25px;
    font-size: 16px;
    cursor: pointer;
    transition: background-color 0.2s;
    &:hover {
        background-color: #357abd;
    }
`;

const WidgetWrapper = styled.div`
    padding: 12px 0;
    transition: transform 0.2s cubic-bezier(0.2, 0, 0, 1), box-shadow 0.2s cubic-bezier(0.2, 0, 0, 1);
    
    ${(props) => props.$isDragging && `
        transform: scale(1.03);
        box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        z-index: 1000;
        opacity: 0.85;
        
        padding: 24px;
        
        display: flex;
        flex-direction: column;
        background-color: #fff4b7ff; 
        border-radius: 16px;
    `}
`;

const getWidgetComponent = (widgetName, props) => {
    switch (widgetName) {
        case 'StatsGrid':
            return <StatsGrid onSwitchTab={props.onSwitchTab} />;
        case 'QuickActions':
            return <QuickActions onSwitchTab={props.onSwitchTab} addActivity={props.addActivity} />;
        case 'RecentActivity':
            const activitiesToDisplay = props.recentActivities.slice(0, props.displayCount);
            return <RecentActivity recentActivities={activitiesToDisplay} deleteActivity={props.deleteActivity} />;
        default:
            return null;
    }
};

const DraggableWidget = ({ id, onSwitchTab, addActivity, recentActivities, displayCount, setDisplayCount, deleteActivity }) => {
    const { attributes, listeners, setNodeRef, transform, transition, isDragging } = useSortable({ id });

    const style = {
        transform: CSS.Transform.toString(transform),
        transition,
    };

    const componentProps = {
        onSwitchTab,
        addActivity,
        recentActivities,
        displayCount,
        setDisplayCount,
        deleteActivity
    };

    return (
        <WidgetWrapper ref={setNodeRef} style={style} $isDragging={isDragging} {...attributes} {...listeners}>
            {getWidgetComponent(id, componentProps)}
        </WidgetWrapper>
    );
};

function App() {
    // âœ… ê¸°ì¡´ ìƒíƒœë“¤ì€ ê·¸ëŒ€ë¡œ ìœ ì§€
    const [isLoading, setIsLoading] = useState(true);
    const [profile, setProfile] = useState(null);
    const [isLoginModalOpen, setIsLoginModalOpen] = useState(false);

    // âœ… ìƒˆë¡œ ì¶”ê°€ë˜ëŠ” ìƒíƒœë“¤
    const [accessToken, setAccessTokenState] = useState(null);
    const [lastSyncTime, setLastSyncTime] = useState(null);
    const syncIntervalRef = useRef(null);
    const syncDebounceRef = useRef(null);
    const [isGapiReady, setIsGapiReady] = useState(false);
    
    const [activeTab, setActiveTab] = useState('home');
    const [isMenuOpen, setIsMenuOpen] = useState(false);
    const [isMacroModalOpen, setIsMacroModalOpen] = useState(false);
    const [isFortuneFlowOpen, setIsFortuneFlowOpen] = useState(false);
    const [isTimerOpen, setIsTimerOpen] = useState(false);
    const [isRestoreConfirmOpen, setIsRestoreConfirmOpen] = useState(false);
    const [restoreType, setRestoreType] = useState('phone'); // 'phone' or 'google'
    const [pendingRestoreFile, setPendingRestoreFile] = useState(null);
    const [isUnshareConfirmOpen, setIsUnshareConfirmOpen] = useState(false);

    // í˜‘ì—…ë°© ìƒíƒœ
    const [isCollaborationRoomOpen, setIsCollaborationRoomOpen] = useState(false);
    const [selectedRoomId, setSelectedRoomId] = useState(null);
    const [previousTab, setPreviousTab] = useState(null); // ë°© ì…ì¥ ì „ íƒ­ ì €ì¥

    const [isDragging, setIsDragging] = useState(false);
    const pullStartTime = useRef(0);
    const [pullDistance, setPullDistance] = useState(0);
    const pullStartY = useRef(0);
    const WIDGET_ACTIVATION_DELAY = 500; // ìœ„ì ¯: 0.5ì´ˆ ì œìë¦¬ ëˆ„ë¦„
    const MIN_PULL_DISTANCE = 110;       // ë™ê¸°í™”: 100px ì´ìƒ ë“œë˜ê·¸
    const PULL_THRESHOLD = 110;          // ì„ê³„ê°’: 100px (ê°€ì´ë“œ ë©”ì‹œì§€ë„ ë™ì¼)
    const MIN_TOUCH_DURATION = 300;      // ìµœì†Œ í„°ì¹˜ ì‹œê°„: 0.3ì´ˆ (ë¹ ë¥¸ ìŠ¤ì™€ì´í”„ ë°©ì§€)

    const handlePullStart = (clientY) => {
        // ìŠ¤í¬ë¡¤ì´ ì •í™•íˆ ìµœìƒë‹¨ì¼ ë•Œë§Œ (ë” ì—„ê²©í•˜ê²Œ)
        if (contentAreaRef.current && contentAreaRef.current.scrollTop > 0) {
            return;
        }

        // ëª¨ë‹¬ì´ ì—´ë ¤ìˆìœ¼ë©´ pull-to-refresh ë¹„í™œì„±í™”
        const hasModalOpen = document.querySelector('.rich-text-editor-overlay') ||
                            document.querySelector('.search-modal-overlay') ||
                            document.querySelector('.modal-overlay');
        if (hasModalOpen) {
            return;
        }

        pullStartY.current = clientY;
        pullStartTime.current = Date.now();
        setIsDragging(true);
        console.log('â±ï¸ Pull ì‹œì‘');
    };

    const handlePullMove = (clientY) => {
        if (!isDragging) return;

        const currentY = clientY;
        const distance = currentY - pullStartY.current;

        // ìŠ¤í¬ë¡¤ ì²´í¬ ì œê±° - ì†ì„ ë–¼ê¸° ì „ê¹Œì§€ëŠ” ì ˆëŒ€ ì·¨ì†Œí•˜ì§€ ì•ŠìŒ

        // ì•„ë˜ë¡œ ë‹¹ê¹€ (30px ë°ë“œì¡´ ì´ˆê³¼)
        if (distance > 30) {
            setPullDistance((distance - 30) * 0.4);
        }
        // ë°ë“œì¡´ ì•ˆìª½ (0~30px)
        else if (distance > 0) {
            setPullDistance(0);
        }
        // ìœ„ë¡œ ì˜¬ë¦´ ë•Œ: ì†ê°€ë½ì„ ë”°ë¼ ìŒìˆ˜ë¡œ ì´ë™ (ë¶€ë“œëŸ½ê²Œ ë³µê·€)
        else {
            setPullDistance(distance * 0.3); // ìŒìˆ˜ ê°’ í—ˆìš©, ì €í•­ê° ì¶”ê°€
        }
    };

    const handlePullEnd = async () => {
        setIsDragging(false);

        const touchDuration = Date.now() - pullStartTime.current;

        console.log('ğŸ”µ handlePullEnd í˜¸ì¶œë¨');
        console.log('ğŸ“ pullDistance:', pullDistance);
        console.log('ğŸ“ PULL_THRESHOLD:', PULL_THRESHOLD);
        console.log('â±ï¸ touchDuration:', touchDuration);

        const shouldSync = pullDistance > PULL_THRESHOLD && touchDuration >= MIN_TOUCH_DURATION;
        console.log('â“ shouldSync:', shouldSync);

        setPullDistance(0);

        if (shouldSync) {
            console.log('âœ… ìˆ˜ë™ ë™ê¸°í™” ì‹œì‘!');
            await handleSync();
        } else {
            if (touchDuration < MIN_TOUCH_DURATION) {
                console.log('âŒ í„°ì¹˜ ì‹œê°„ ë¶€ì¡± - ë™ê¸°í™” ì•ˆ í•¨ (ë¹ ë¥¸ ìŠ¤ì™€ì´í”„)');
            } else {
                console.log('âŒ ê±°ë¦¬ ë¶€ì¡± - ë™ê¸°í™” ì•ˆ í•¨');
            }
        }
    };

    // âœ… ì¶”ê°€: ì•± í™œì„± ìƒíƒœ (í¬ì»¤ìŠ¤ ì—¬ë¶€)
    const [isAppActive, setIsAppActive] = useState(true); 

    const [isUserIdle, setIsUserIdle] = useState(false);
    const idleTimerRef = useRef(null);
    const IDLE_TIMEOUT = 5 * 60 * 1000; // 5ë¶„

    // ê¸°ì¡´ useEffect (ì•± í™œì„± ìƒíƒœ ë¦¬ìŠ¤ë„ˆ)
    useEffect(() => {
        const handleVisibilityChange = () => {
            setIsAppActive(document.visibilityState === 'visible');
        };

        document.addEventListener('visibilitychange', handleVisibilityChange);
        return () => {
            document.removeEventListener('visibilitychange', handleVisibilityChange);
        };
    }, []);

    useEffect(() => {
        const resetIdleTimer = () => {
            setIsUserIdle(false);
            
            if (idleTimerRef.current) {
                clearTimeout(idleTimerRef.current);
            }
            
            idleTimerRef.current = setTimeout(() => {
                setIsUserIdle(true);
                console.log('â¸ï¸ ì‚¬ìš©ì ë¹„í™œì„± ìƒíƒœ - ìë™ ë™ê¸°í™” ì¤‘ì§€');
            }, IDLE_TIMEOUT);
        };

        // ì‚¬ìš©ì í™œë™ ê°ì§€ ì´ë²¤íŠ¸ë“¤
        const events = ['mousedown', 'mousemove', 'keypress', 'scroll', 'touchstart', 'click'];
        
        events.forEach(event => {
            document.addEventListener(event, resetIdleTimer, true);
        });

        // ì´ˆê¸° íƒ€ì´ë¨¸ ì‹œì‘
        resetIdleTimer();

        return () => {
            events.forEach(event => {
                document.removeEventListener(event, resetIdleTimer, true);
            });
            if (idleTimerRef.current) {
                clearTimeout(idleTimerRef.current);
            }
        };
    }, []);

    // ğŸ”„ ì¼ë°˜ ë°ì´í„°ëŠ” ë¡œê·¸ì¸/ê²ŒìŠ¤íŠ¸ ê³µí†µ ì €ì¥ (ë™ì¼í•œ localStorage í‚¤ ì‚¬ìš©)
    // âœ… íœ´ëŒ€í° í™˜ê²½: ë¡œê·¸ì¸ ìƒíƒœë¥¼ ì¸ì§€ ëª»í•œ ì±„ ë©”ëª¨ ì‘ì„± ì‹œ ë°ì´í„° ìœ ì‹¤ ë°©ì§€
    // âœ… Google Drive ë™ê¸°í™”ëŠ” ë¡œê·¸ì¸ ì‹œì—ë§Œ ê°€ëŠ¥
    // âœ… ë°±ì—…/ë³µì› ê¸°ëŠ¥ì€ ê²ŒìŠ¤íŠ¸ì™€ ë¡œê·¸ì¸ ëª¨ë‘ ê°€ëŠ¥

    // ğŸ“¦ ê¸°ì¡´ ë°ì´í„° ë§ˆì´ê·¸ë ˆì´ì…˜ (ìµœì´ˆ 1íšŒë§Œ ì‹¤í–‰)
    useEffect(() => {
        const migrationKey = 'data_migration_v1_completed';
        if (localStorage.getItem(migrationKey)) return; // ì´ë¯¸ ë§ˆì´ê·¸ë ˆì´ì…˜ ì™„ë£Œ

        console.log('ğŸ“¦ ë°ì´í„° ë§ˆì´ê·¸ë ˆì´ì…˜ ì‹œì‘...');

        // ëª¨ë“  localStorage í‚¤ í™•ì¸
        const allKeys = Object.keys(localStorage);
        const guestKeys = allKeys.filter(key => key.endsWith('_guest'));
        const userKeys = allKeys.filter(key => key.includes('@') && !key.includes('_shared'));

        // ë³‘í•©í•  ë°ì´í„° íƒ€ì…ë“¤
        const dataTypes = ['memos', 'calendarSchedules', 'recentActivities', 'widgets', 'displayCount'];

        dataTypes.forEach(dataType => {
            const sharedKey = `${dataType}_shared`;
            const existingShared = localStorage.getItem(sharedKey);

            // ì´ë¯¸ _shared í‚¤ì— ë°ì´í„°ê°€ ìˆìœ¼ë©´ ìŠ¤í‚µ (ìˆ˜ë™ìœ¼ë¡œ ìƒì„±í•œ ê²½ìš°)
            if (existingShared) {
                console.log(`âœ… ${dataType}: ì´ë¯¸ ê³µí†µ ë°ì´í„° ì¡´ì¬ (ìŠ¤í‚µ)`);
                return;
            }

            // guest ë°ì´í„°ì™€ user ë°ì´í„°ë¥¼ ëª¨ë‘ ì°¾ì•„ì„œ ë³‘í•©
            let mergedData = dataType === 'calendarSchedules' ? {} : [];
            let foundData = false;

            // guest í‚¤ì—ì„œ ë°ì´í„° ê°€ì ¸ì˜¤ê¸°
            const guestKey = `${dataType}_guest`;
            const guestData = localStorage.getItem(guestKey);
            if (guestData) {
                try {
                    const parsed = JSON.parse(guestData);
                    if (dataType === 'calendarSchedules') {
                        mergedData = { ...mergedData, ...parsed };
                    } else if (Array.isArray(parsed)) {
                        mergedData = [...mergedData, ...parsed];
                    } else if (dataType === 'displayCount') {
                        mergedData = parsed;
                    }
                    foundData = true;
                    console.log(`ğŸ“¥ ${dataType}_guest ë°ì´í„° ë°œê²¬:`, parsed);
                } catch (e) {
                    console.error(`âŒ ${guestKey} íŒŒì‹± ì‹¤íŒ¨:`, e);
                }
            }

            // user í‚¤ì—ì„œ ë°ì´í„° ê°€ì ¸ì˜¤ê¸° (ì´ë©”ì¼ ì£¼ì†Œ í¬í•¨ëœ í‚¤)
            userKeys.forEach(key => {
                if (key.startsWith(dataType + '_')) {
                    const userData = localStorage.getItem(key);
                    if (userData) {
                        try {
                            const parsed = JSON.parse(userData);
                            if (dataType === 'calendarSchedules') {
                                mergedData = { ...mergedData, ...parsed };
                            } else if (Array.isArray(parsed)) {
                                mergedData = [...mergedData, ...parsed];
                            } else if (dataType === 'displayCount' && !foundData) {
                                // displayCountëŠ” ì²« ë²ˆì§¸ ê°’ë§Œ ì‚¬ìš©
                                mergedData = parsed;
                            }
                            foundData = true;
                            console.log(`ğŸ“¥ ${key} ë°ì´í„° ë°œê²¬:`, parsed);
                        } catch (e) {
                            console.error(`âŒ ${key} íŒŒì‹± ì‹¤íŒ¨:`, e);
                        }
                    }
                }
            });

            // ë³‘í•©ëœ ë°ì´í„°ê°€ ìˆìœ¼ë©´ _shared í‚¤ë¡œ ì €ì¥
            if (foundData) {
                localStorage.setItem(sharedKey, JSON.stringify(mergedData));
                console.log(`âœ… ${sharedKey}ë¡œ ë§ˆì´ê·¸ë ˆì´ì…˜ ì™„ë£Œ:`, mergedData);
            } else {
                console.log(`ğŸ“­ ${dataType}: ë§ˆì´ê·¸ë ˆì´ì…˜í•  ë°ì´í„° ì—†ìŒ`);
            }
        });

        // ë§ˆì´ê·¸ë ˆì´ì…˜ ì™„ë£Œ í”Œë˜ê·¸ ì €ì¥
        localStorage.setItem(migrationKey, 'true');
        console.log('âœ… ë°ì´í„° ë§ˆì´ê·¸ë ˆì´ì…˜ ì™„ë£Œ');

        // í˜ì´ì§€ ìƒˆë¡œê³ ì¹¨í•˜ì—¬ ìƒˆë¡œìš´ í‚¤ë¡œ ë°ì´í„° ë¡œë“œ
        window.location.reload();
    }, []);

    const [widgets, setWidgets] = useLocalStorage('widgets_shared', ['StatsGrid', 'QuickActions', 'RecentActivity']);
    const [memos, setMemos] = useLocalStorage('memos_shared', []);
    const [recentActivities, setRecentActivities] = useLocalStorage('recentActivities_shared', []);
    const [calendarSchedules, setCalendarSchedules] = useLocalStorage('calendarSchedules_shared', {});
    const [displayCount, setDisplayCount] = useLocalStorage('displayCount_shared', 5);
    
    const [isSearchModalOpen, setIsSearchModalOpen] = useState(false);
    const contentAreaRef = useRef(null);
    
    const [isCalendarEditorOpen, setIsCalendarEditorOpen] = useState(false);
    const [calendarModalData, setCalendarModalData] = useState({ date: new Date(), text: '' });
    
    const urlParams = new URLSearchParams(window.location.search);
    const secretKeyFromUrl = urlParams.get('secret');
    const adminSecretKey = import.meta.env.VITE_ADMIN_SECRET_KEY;
    const isAdminMode = secretKeyFromUrl === adminSecretKey;
    
    const handleOpenCalendarEditor = (date, text) => {
        const key = format(new Date(date), 'yyyy-MM-dd');
        const scheduleData = calendarSchedules[key] || {}; // ë‚ ì§œ í‚¤ë¡œ ì „ì²´ ìŠ¤ì¼€ì¤„ ë°ì´í„° ì¡°íšŒ

        // ëª¨ë‹¬ì— ì „ë‹¬í•  ë°ì´í„°ì— íƒ€ì„ìŠ¤íƒ¬í”„ì™€ ì•ŒëŒ ì •ë³´ ì¶”ê°€
        setCalendarModalData({
            date,
            text: scheduleData.text ?? text, // í…ìŠ¤íŠ¸ëŠ” ê¸°ì¡´ ë°©ì‹ì„ ìœ ì§€
            createdAt: scheduleData.createdAt, // ì‘ì„±ì¼ ì¶”ê°€
            updatedAt: scheduleData.updatedAt, // ìˆ˜ì •ì¼ ì¶”ê°€
            alarm: scheduleData.alarm // ì•ŒëŒ ì •ë³´ ì¶”ê°€
        });
        setIsCalendarEditorOpen(true);
    };

    const handleCalendarScheduleSave = (date, text) => {
            if (!date) return;

            const key = format(new Date(date), 'yyyy-MM-dd');
            const now = Date.now();

            const isEditingExisting = !!calendarSchedules[key];

            setCalendarSchedules(prev => {
                const copy = { ...prev };

                if (!text || text.trim() === "") {
                    // í…ìŠ¤íŠ¸ê°€ ë¹„ì–´ìˆìœ¼ë©´ textë§Œ ì‚­ì œí•˜ë˜, alarmì´ ìˆìœ¼ë©´ ì—”íŠ¸ë¦¬ ìœ ì§€
                    if (copy[key]) {
                        if (copy[key].alarm && copy[key].alarm.registeredAlarms && copy[key].alarm.registeredAlarms.length > 0) {
                            // ì•ŒëŒì´ ìˆìœ¼ë©´ textë§Œ ë¹ˆ ë¬¸ìì—´ë¡œ
                            copy[key] = {
                                ...copy[key],
                                text: '',
                                updatedAt: now
                            };
                        } else {
                            // ì•ŒëŒë„ ì—†ìœ¼ë©´ ì „ì²´ ì‚­ì œ
                            delete copy[key];
                        }
                    }
                } else {
                    copy[key] = {
                        text,
                        createdAt: copy[key]?.createdAt ?? now,
                        updatedAt: now,
                        alarm: copy[key]?.alarm, // ê¸°ì¡´ ì•ŒëŒ ì •ë³´ ë³´ì¡´
                    };
                }
                return copy;
            });

            if (!text || text.trim() === "") {
                addActivity('ìŠ¤ì¼€ì¤„ ì‚­ì œ', `${key}`);
                showToast?.('âœ“ ìŠ¤ì¼€ì¤„ì´ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤');
            } else {
                const activityType = isEditingExisting ? 'ìŠ¤ì¼€ì¤„ ìˆ˜ì •' : 'ìŠ¤ì¼€ì¤„ ë“±ë¡';
                const toastMessage = isEditingExisting ? 'âœ“ ìŠ¤ì¼€ì¤„ì´ ìˆ˜ì •ë˜ì—ˆìŠµë‹ˆë‹¤' : 'âœ“ ìŠ¤ì¼€ì¤„ì´ ë“±ë¡ë˜ì—ˆìŠµë‹ˆë‹¤';

                addActivity(activityType, `${key} - ${text}`);
                showToast?.(toastMessage);
            }

            setIsCalendarEditorOpen(false);
            quietSync(); // âœ… ì¶”ê°€
        };

    const handleProfileClick = () => {
        setIsMenuOpen(false);
        setActiveTab('profile');
    };   

    const logOut = () => {
        setProfile(null);
        setUser(null);
    };

    const handleOpenFortune = () => {
        setIsFortuneFlowOpen(true);
        // ì‚¬ì´ë“œ ë©”ë‰´ëŠ” ì´ë¯¸ SideMenu.jsx ë‚´ë¶€ì—ì„œ ë‹«í˜”ë‹¤ê³  ê°€ì •
    };

    const addActivity = (type, description, memoId = null) => {
        const allowedTypes = ['ë©”ëª¨ ì‘ì„±', 'ë©”ëª¨ ìˆ˜ì •', 'ë©”ëª¨ ì‚­ì œ', 'ë°±ì—…', 'ë³µì›', 'ìŠ¤ì¼€ì¤„ ë“±ë¡', 'ìŠ¤ì¼€ì¤„ ìˆ˜ì •', 'ìŠ¤ì¼€ì¤„ ì‚­ì œ', 'ë¦¬ë·° ì‘ì„±', 'ë™ê¸°í™”'];
        if (!allowedTypes.includes(type)) {
            return;
        }

        // ìŠ¤ì¼€ì¤„ ê´€ë ¨ì€ 23ê¸€ì, ë‚˜ë¨¸ì§€ëŠ” 20ê¸€ì
        const maxLength = type.includes('ìŠ¤ì¼€ì¤„') ? 23 : 20;

        // ì´ëª¨ì§€ë¥¼ ì˜¬ë°”ë¥´ê²Œ ì¹´ìš´íŠ¸
        const chars = [...description];
        const trimmedDescription = chars.length > maxLength
            ? chars.slice(0, maxLength).join('') + '...'
            : description;

        const formattedDescription = `${type} - ${trimmedDescription}`;

        setRecentActivities(prevActivities => {
            const now = Date.now();
            const newActivity = {
                id: now, 
                memoId: memoId,
                type,
                description: formattedDescription,
                date: new Date(now).toLocaleString('ko-KR', {
                    year: 'numeric',
                    month: '2-digit',
                    day: '2-digit',
                    hour: '2-digit',
                    minute: '2-digit',
                    second: '2-digit',
                })
            };
            const updatedActivities = [newActivity, ...prevActivities];
            return updatedActivities.slice(0, 15);
        });
    };
    
    const [isNewMemoModalOpen, setIsNewMemoModalOpen] = useState(false);
    const [isDetailModalOpen, setIsDetailModalOpen] = useState(false);
    const [selectedMemo, setSelectedMemo] = useState(null);
    const [toastMessage, setToastMessage] = useState(null);
    const [memoOpenSource, setMemoOpenSource] = useState(null);
    const [isSelectionMode, setIsSelectionMode] = useState(false);
    const [selectedMemoIds, setSelectedMemoIds] = useState(new Set());
    
    const [isDeleteModalOpen, setIsDeleteModalOpen] = useState(false);
    const [memoToDelete, setMemoToDelete] = useState(null);
    const [isCalendarConfirmOpen, setIsCalendarConfirmOpen] = useState(false);
    const [dateToDelete, setDateToDelete] = useState(null);
    
    const [isAlarmModalOpen, setIsAlarmModalOpen] = useState(false);
    const [scheduleForAlarm, setScheduleForAlarm] = useState(null);
    const [isDateSelectorOpen, setIsDateSelectorOpen] = useState(false);

    // ì•ŒëŒ ë§¤ë‹ˆì € í›… ì‚¬ìš©
    const { currentAlarm, dismissAlarm, snoozeAlarm } = useAlarmManager(calendarSchedules);

    // ì•ŒëŒ ë¹„í™œì„±í™” ì²˜ë¦¬ (ì¼ë°˜ ì•ŒëŒì´ ìš¸ë¦° í›„)
    const handleAlarmDismissed = (alarm) => {
        setCalendarSchedules(prevSchedules => {
            const updatedSchedules = { ...prevSchedules };

            // ì•ŒëŒì´ ì†í•œ ìŠ¤ì¼€ì¤„ ì°¾ê¸°
            Object.keys(updatedSchedules).forEach(dateKey => {
                const schedule = updatedSchedules[dateKey];
                if (schedule.alarm && schedule.alarm.registeredAlarms) {
                    const alarmIndex = schedule.alarm.registeredAlarms.findIndex(a => a.id === alarm.id);
                    if (alarmIndex !== -1) {
                        // ì•ŒëŒ ë¹„í™œì„±í™” ë° ë¹„í™œì„±í™” ì‹œê°„ ê¸°ë¡
                        updatedSchedules[dateKey] = {
                            ...schedule,
                            alarm: {
                                ...schedule.alarm,
                                registeredAlarms: schedule.alarm.registeredAlarms.map((a, idx) =>
                                    idx === alarmIndex
                                        ? { ...a, enabled: false, disabledAt: Date.now() }
                                        : a
                                )
                            }
                        };
                        console.log(`ğŸ”• ì•ŒëŒ ë¹„í™œì„±í™”: ${alarm.title || alarm.id}`);
                    }
                }
            });

            return updatedSchedules;
        });
    };

    // ë¹„í™œì„±í™”ëœ ì•ŒëŒ ìë™ ì‚­ì œ (7ì¼ í›„)
    useEffect(() => {
        const AUTO_DELETE_DAYS = 7;

        const deleteExpiredAlarms = () => {
            const now = Date.now();
            let deletedCount = 0;

            setCalendarSchedules(prevSchedules => {
                const updatedSchedules = { ...prevSchedules };

                Object.keys(updatedSchedules).forEach(dateKey => {
                    const schedule = updatedSchedules[dateKey];
                    if (schedule.alarm && schedule.alarm.registeredAlarms) {
                        const beforeCount = schedule.alarm.registeredAlarms.length;

                        // ê¸°ë…ì¼ì´ ì•„ë‹ˆê³  ë¹„í™œì„±í™”ëœ ì§€ 7ì¼ì´ ì§€ë‚œ ì•ŒëŒ ì‚­ì œ
                        const filteredAlarms = schedule.alarm.registeredAlarms.filter(alarm => {
                            if (alarm.isAnniversary) return true; // ê¸°ë…ì¼ ì•ŒëŒì€ ìœ ì§€
                            if (alarm.enabled !== false) return true; // í™œì„± ì•ŒëŒì€ ìœ ì§€
                            if (!alarm.disabledAt) return true; // ë¹„í™œì„±í™” ì‹œê°„ì´ ì—†ìœ¼ë©´ ìœ ì§€

                            const daysSinceDisabled = (now - alarm.disabledAt) / (1000 * 60 * 60 * 24);
                            return daysSinceDisabled < AUTO_DELETE_DAYS;
                        });

                        if (filteredAlarms.length < beforeCount) {
                            deletedCount += (beforeCount - filteredAlarms.length);
                            updatedSchedules[dateKey] = {
                                ...schedule,
                                alarm: {
                                    ...schedule.alarm,
                                    registeredAlarms: filteredAlarms
                                }
                            };
                        }
                    }
                });

                if (deletedCount > 0) {
                    console.log(`ğŸ—‘ï¸ ìë™ ì‚­ì œ: ${deletedCount}ê°œì˜ ë§Œë£Œëœ ì•ŒëŒ ì‚­ì œë¨`);
                }

                return updatedSchedules;
            });
        };

        // ì•± ì‹œì‘ ì‹œ ì¦‰ì‹œ ì‹¤í–‰
        deleteExpiredAlarms();

        // ë§¤ì¼ ìì •ì— ì‹¤í–‰
        const now = new Date();
        const tomorrow = new Date(now.getFullYear(), now.getMonth(), now.getDate() + 1);
        const msUntilMidnight = tomorrow - now;

        const midnightTimer = setTimeout(() => {
            deleteExpiredAlarms();

            // ì´í›„ 24ì‹œê°„ë§ˆë‹¤ ì‹¤í–‰
            const dailyInterval = setInterval(deleteExpiredAlarms, 24 * 60 * 60 * 1000);
            return () => clearInterval(dailyInterval);
        }, msUntilMidnight);

        return () => clearTimeout(midnightTimer);
    }, []);

    // ì•± ì‹œì‘ ì‹œ ì¼ì • ë°ì´í„° ì •ë¦¬ (textê°€ ì—†ìœ¼ë©´ createdAt/updatedAt ì œê±°)
    useEffect(() => {
        setCalendarSchedules(prevSchedules => {
            const updatedSchedules = { ...prevSchedules };
            let hasChanges = false;

            Object.keys(updatedSchedules).forEach(dateKey => {
                const schedule = updatedSchedules[dateKey];

                // textê°€ ì—†ê±°ë‚˜ ë¹ˆ ë¬¸ìì—´ì¸ ê²½ìš° createdAt/updatedAt ì œê±°
                if (!schedule.text || schedule.text.trim() === '') {
                    if (schedule.createdAt || schedule.updatedAt) {
                        hasChanges = true;
                        const { createdAt, updatedAt, ...rest } = schedule;

                        // ì•ŒëŒì´ ìˆìœ¼ë©´ ì•ŒëŒë§Œ ìœ ì§€
                        if (rest.alarm && rest.alarm.registeredAlarms && rest.alarm.registeredAlarms.length > 0) {
                            updatedSchedules[dateKey] = rest;
                        } else {
                            // ì•ŒëŒë„ ì—†ìœ¼ë©´ ì—”íŠ¸ë¦¬ ì „ì²´ ì‚­ì œ
                            delete updatedSchedules[dateKey];
                        }
                    }
                }
            });

            return hasChanges ? updatedSchedules : prevSchedules;
        });
    }, []); // ì•± ì‹œì‘ ì‹œ í•œ ë²ˆë§Œ ì‹¤í–‰

    const handleOpenAlarmModal = (scheduleData) => {
        console.log('âœ… handleOpenAlarmModal í˜¸ì¶œë¨:', scheduleData);
        setScheduleForAlarm(scheduleData);
        setIsAlarmModalOpen(true);
    };

    const handleSaveAlarm = (alarmSettings, actionType) => {
        // 1. ì•ŒëŒì„ ì„¤ì •í•  ëŒ€ìƒ ìŠ¤ì¼€ì¤„ì˜ ë‚ ì§œ í‚¤(key)ë¥¼ ì°¾ìŠµë‹ˆë‹¤.
        if (!scheduleForAlarm?.date) {
            console.error("ì•ŒëŒì„ ì €ì¥í•  ìŠ¤ì¼€ì¤„ ì •ë³´ê°€ ì—†ìŠµë‹ˆë‹¤.");
            return;
        }
        const key = format(new Date(scheduleForAlarm.date), 'yyyy-MM-dd');

        // 2. calendarSchedules ìƒíƒœë¥¼ ì—…ë°ì´íŠ¸í•©ë‹ˆë‹¤.
        setCalendarSchedules(prevSchedules => {
            const updatedSchedules = { ...prevSchedules };
            const targetSchedule = updatedSchedules[key];

            // 3. í•´ë‹¹ ë‚ ì§œì˜ ìŠ¤ì¼€ì¤„ì— 'alarm' ê°ì²´ë¥¼ ì¶”ê°€í•˜ê±°ë‚˜ ì—…ë°ì´íŠ¸í•©ë‹ˆë‹¤.
            if (targetSchedule) {
                // ê¸°ì¡´ ì¼ì •ì´ ìˆëŠ” ê²½ìš°
                updatedSchedules[key] = {
                    ...targetSchedule,
                    alarm: alarmSettings
                };
            } else {
                // ì¼ì •ì´ ì—†ëŠ” ê²½ìš° ì•ŒëŒë§Œ ì €ì¥ (createdAt/updatedAtì€ ì‹¤ì œ ì¼ì • ì €ì¥ ì‹œì—ë§Œ ìƒì„±)
                updatedSchedules[key] = {
                    text: '',  // ë¹ˆ ì¼ì •
                    alarm: alarmSettings
                };
            }

            return updatedSchedules;
        });

        // 4. ì‚¬ìš©ìì—ê²Œ í”¼ë“œë°±ì„ ì¤ë‹ˆë‹¤ (ëª¨ë‹¬ì€ ë‹«ì§€ ì•ŠìŒ)
        const hasAlarms = alarmSettings.registeredAlarms && alarmSettings.registeredAlarms.length > 0;

        // ë™ì‘ íƒ€ì…ì— ë”°ë¼ ë‹¤ë¥¸ ë©”ì‹œì§€ í‘œì‹œ
        let message = 'ì´ë²¤íŠ¸ ì‹œê°„ì´ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤.';

        if (hasAlarms) {
            const alarmType = alarmSettings.alarmType; // 'anniversary' or 'normal'

            switch (actionType) {
                case 'register':
                    message = alarmType === 'anniversary' ? 'ê¸°ë…ì¼ì„ ë“±ë¡í•˜ì˜€ìŠµë‹ˆë‹¤. ğŸ””' : 'ì•ŒëŒì„ ë“±ë¡í•˜ì˜€ìŠµë‹ˆë‹¤. ğŸ””';
                    break;
                case 'update':
                case 'edit':
                    message = alarmType === 'anniversary' ? 'ê¸°ë…ì¼ì„ ìˆ˜ì •í•˜ì˜€ìŠµë‹ˆë‹¤.' : 'ì•ŒëŒì„ ìˆ˜ì •í•˜ì˜€ìŠµë‹ˆë‹¤.';
                    break;
                case 'delete':
                    message = alarmType === 'anniversary' ? 'ê¸°ë…ì¼ì„ ì‚­ì œí•˜ì˜€ìŠµë‹ˆë‹¤.' : 'ì•ŒëŒì„ ì‚­ì œí•˜ì˜€ìŠµë‹ˆë‹¤.';
                    break;
                case 'toggle_on':
                    message = alarmType === 'anniversary' ? 'ê¸°ë…ì¼ ì•ŒëŒì´ í™œì„±í™” ë˜ì—ˆìŠµë‹ˆë‹¤.' : 'ì•ŒëŒì´ í™œì„±í™” ë˜ì—ˆìŠµë‹ˆë‹¤.';
                    break;
                case 'toggle_off':
                    message = alarmType === 'anniversary' ? 'ê¸°ë…ì¼ ì•ŒëŒì´ ì¼ì‹œì¤‘ì§€ ë˜ì—ˆìŠµë‹ˆë‹¤.' : 'ì•ŒëŒì´ ì¼ì‹œì¤‘ì§€ ë˜ì—ˆìŠµë‹ˆë‹¤.';
                    break;
                case 'apply':
                    message = 'ë³€ê²½ì‚¬í•­ì´ ì ìš©ë˜ì—ˆìŠµë‹ˆë‹¤.';
                    break;
                case 'save':
                    message = 'ì•ŒëŒ ì„¤ì •ì´ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤.';
                    break;
                default:
                    message = 'ì•ŒëŒì´ ì„¤ì •ë˜ì—ˆìŠµë‹ˆë‹¤. ğŸ””';
            }
        }

        showToast(message);
        // ëª¨ë‹¬ì€ ì‚¬ìš©ìê°€ ì§ì ‘ ë‹«ê¸° ë²„íŠ¼ì„ ëˆ„ë¥¼ ë•Œë§Œ ë‹«íˆë„ë¡ ë³€ê²½
        // setIsAlarmModalOpen(false);
        // setScheduleForAlarm(null);
    };

    const requestCalendarDelete = (date) => {
        setDateToDelete(date);
        setIsCalendarConfirmOpen(true);
    };

    const showToast = (message) => {
        console.log('ğŸ”” showToast í˜¸ì¶œë¨:', message);
        setToastMessage(message);
        setTimeout(() => {
            console.log('ğŸ”” Toast ìˆ¨ê¹€');
            setToastMessage(null);
        }, 1000); // 1ì´ˆë¡œ ë‹¨ì¶•
    };
    
    const handleDataExport = async () => {
        // ì „ì²´ ë°ì´í„° ë°±ì—… (ìš´ì„¸ ì œì™¸)
        const dataToExport = {
            version: '1.0',
            exportDate: new Date().toISOString(),
            exportTimestamp: Date.now(),
            data: {
                memos,
                calendarSchedules,
                recentActivities,
                widgets,
                displayCount,
                trashedItems: JSON.parse(localStorage.getItem('trashedItems_shared') || '[]'),
                macroTexts: JSON.parse(localStorage.getItem('macroTexts') || '[]'),
                memoFolders: JSON.parse(localStorage.getItem('memoFolders') || '[]')
            }
        };

        // 1. íœ´ëŒ€í°ì— íŒŒì¼ ë‹¤ìš´ë¡œë“œ (ëª¨ë“  ì‚¬ìš©ì)
        exportData('mindflow_backup', dataToExport);

        // 2. ë¡œê·¸ì¸ ì‚¬ìš©ìëŠ” Google Driveì—ë„ ë°±ì—…
        if (profile && accessToken) {
            try {
                const result = await backupToGoogleDrive(dataToExport);
                if (result.success) {
                    addActivity('ë°±ì—…', 'íœ´ëŒ€í° ë° Google Driveì— ë°±ì—… ì™„ë£Œ');
                    showToast('âœ“ íœ´ëŒ€í°ê³¼ Google Driveì— ë°±ì—…ë˜ì—ˆìŠµë‹ˆë‹¤');
                } else {
                    addActivity('ë°±ì—…', 'íœ´ëŒ€í°ì— ë°±ì—… ì™„ë£Œ (Drive ì‹¤íŒ¨)');
                    showToast('âœ“ íœ´ëŒ€í°ì— ë°±ì—…ë˜ì—ˆìŠµë‹ˆë‹¤');
                }
            } catch (error) {
                console.error('Google Drive ë°±ì—… ì‹¤íŒ¨:', error);
                addActivity('ë°±ì—…', 'íœ´ëŒ€í°ì— ë°±ì—… ì™„ë£Œ');
                showToast('âœ“ íœ´ëŒ€í°ì— ë°±ì—…ë˜ì—ˆìŠµë‹ˆë‹¤');
            }
        } else {
            addActivity('ë°±ì—…', 'íœ´ëŒ€í°ì— ë°±ì—… ì™„ë£Œ');
        }
    };

    const handleDataImport = (event) => {
        const file = event.target.files[0];
        if (!file) return;

        // íŒŒì¼ì„ ì €ì¥í•˜ê³  í™•ì¸ ëª¨ë‹¬ í‘œì‹œ
        setPendingRestoreFile(file);
        setRestoreType('phone');
        setIsRestoreConfirmOpen(true);
    };

    const executeDataImport = () => {
        if (!pendingRestoreFile) return;

        importData(pendingRestoreFile, (importedData) => {
            try {
                // ë²„ì „ ì²´í¬
                if (importedData.version && importedData.data) {
                    // v1.0 í˜•ì‹ (ìƒˆ í˜•ì‹)
                    const { data } = importedData;
                    if (data.memos) setMemos(data.memos);
                    if (data.calendarSchedules) setCalendarSchedules(data.calendarSchedules);
                    if (data.recentActivities) setRecentActivities(data.recentActivities);
                    if (data.widgets) setWidgets(data.widgets);
                    if (data.displayCount) setDisplayCount(data.displayCount);
                    if (data.trashedItems) {
                        localStorage.setItem('trashedItems_shared', JSON.stringify(data.trashedItems));
                    }
                    if (data.macroTexts) {
                        localStorage.setItem('macroTexts', JSON.stringify(data.macroTexts));
                    }
                    if (data.memoFolders) {
                        localStorage.setItem('memoFolders', JSON.stringify(data.memoFolders));
                    }
                } else if (Array.isArray(importedData)) {
                    // êµ¬ í˜•ì‹ (ë©”ëª¨ë§Œ ìˆëŠ” ê²½ìš°)
                    setMemos(importedData);
                } else {
                    // ì•Œ ìˆ˜ ì—†ëŠ” í˜•ì‹
                    throw new Error('ì§€ì›í•˜ì§€ ì•ŠëŠ” ë°±ì—… íŒŒì¼ í˜•ì‹ì…ë‹ˆë‹¤.');
                }

                showToast('âœ“ ë°ì´í„°ê°€ ì„±ê³µì ìœ¼ë¡œ ë³µì›ë˜ì—ˆìŠµë‹ˆë‹¤');
                addActivity('ë³µì›', 'ì „ì²´ ë°ì´í„° ë³µì› (íœ´ëŒ€í°)');
                setTimeout(() => window.location.reload(), 1500);
            } catch (error) {
                console.error('ë³µì› ì‹¤íŒ¨:', error);
                showToast('âš  ë³µì›ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤');
            }
        });

        // ì´ˆê¸°í™”
        setPendingRestoreFile(null);
        setIsRestoreConfirmOpen(false);
    };
    
    const handleSaveNewMemo = (newMemoContent, isImportant) => {
            const now = Date.now();
            const newId = `m${now}`;
            const newMemo = {
                id: newId,
                content: newMemoContent,
                date: now,
                createdAt: now,
                updatedAt: now,
                displayDate: new Date(now).toLocaleString(),
                isImportant: isImportant,
                folderId: newMemoFolderId || null // í´ë” ID ì €ì¥ (nullì´ë©´ ë¯¸ë¶„ë¥˜)
            };
            setMemos(prevMemos => [newMemo, ...prevMemos]);
            addActivity('ë©”ëª¨ ì‘ì„±', newMemoContent, newId);
            setIsNewMemoModalOpen(false);
            setNewMemoFolderId(null); // í´ë” ID ì´ˆê¸°í™”
            showToast("âœ“ ë©”ëª¨ê°€ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤");
            quietSync(); // âœ… ì¶”ê°€
        };

    const handleEditMemo = (id, newContent, isImportant, folderId, previousFolderId) => {
            const now = Date.now();
            setMemos(prevMemos =>
                prevMemos.map(memo => {
                    if (memo.id === id) {
                        return {
                            ...memo,
                            content: newContent,
                            date: now,
                            createdAt: memo.createdAt || now, // ê¸°ì¡´ createdAt ìœ ì§€, ì—†ìœ¼ë©´ í˜„ì¬ ì‹œê°„
                            updatedAt: now,
                            displayDate: new Date(now).toLocaleString(),
                            isImportant: isImportant,
                            folderId: folderId !== undefined ? folderId : memo.folderId, // í´ë” ID ì €ì¥
                            previousFolderId: previousFolderId !== undefined ? previousFolderId : memo.previousFolderId // ì´ì „ í´ë” ID ì €ì¥
                        };
                    }
                    return memo;
                })
            );
            addActivity('ë©”ëª¨ ìˆ˜ì •', newContent, id);
            setIsDetailModalOpen(false);
            showToast("âœ“ ë©”ëª¨ê°€ ìˆ˜ì •ë˜ì—ˆìŠµë‹ˆë‹¤");
            quietSync(); // âœ… ì¶”ê°€
        };

    const handleDeleteMemo = (id) => {
            const deletedMemo = memos.find(memo => memo.id === id);
            if (deletedMemo) {
                // íœ´ì§€í†µìœ¼ë¡œ ì´ë™ ì´ë²¤íŠ¸ ë°œìƒ
                const event = new CustomEvent('moveToTrash', {
                    detail: {
                        id: deletedMemo.id,
                        type: 'memo',
                        content: deletedMemo.content.substring(0, 50) + (deletedMemo.content.length > 50 ? '...' : ''),
                        originalData: deletedMemo
                    }
                });
                window.dispatchEvent(event);
                
                // ë©”ëª¨ ëª©ë¡ì—ì„œ ì œê±°
                setMemos(prevMemos => prevMemos.filter(memo => memo.id !== id));
                addActivity('ë©”ëª¨ ì‚­ì œ', deletedMemo.content, id);
                quietSync(); // âœ… ì¶”ê°€
            }
            return deletedMemo; 
        };
    
    const handleStartSelectionMode = (memoId) => {
        setIsSelectionMode(true);
        setSelectedMemoIds(new Set([memoId]));
    };

    const handleToggleMemoSelection = (memoId) => {
        setSelectedMemoIds(prevIds => {
            const newIds = new Set(prevIds);
            if (newIds.has(memoId)) {
                newIds.delete(memoId);
            } else {
                newIds.add(memoId);
            }
            // ì „ì²´í•´ì œ ì‹œì—ë„ ì„ íƒ ëª¨ë“œëŠ” ìœ ì§€ë˜ì–´ì•¼ í•¨
            // ì‚¬ìš©ìê°€ ëª…ì‹œì ìœ¼ë¡œ "ì·¨ì†Œ" ë²„íŠ¼ì„ ëˆŒëŸ¬ì•¼ë§Œ ì„ íƒ ëª¨ë“œ ì¢…ë£Œ
            return newIds;
        });
    };

    const handleExitSelectionMode = () => {
        setIsSelectionMode(false);
        setSelectedMemoIds(new Set());
    };

    const handleToggleSelectedMemosImportance = () => {
        if (selectedMemoIds.size === 0) return;

        // ì„ íƒëœ ë©”ëª¨ ê°ì²´ë“¤ ê°€ì ¸ì˜¤ê¸°
        const selectedMemoObjects = memos.filter(memo => selectedMemoIds.has(memo.id));

        // ì„ íƒëœ ë©”ëª¨ ì¤‘ í•˜ë‚˜ë¼ë„ ì¤‘ìš”í•˜ì§€ ì•Šìœ¼ë©´ ëª¨ë‘ ì¤‘ìš”ë¡œ, ëª¨ë‘ ì¤‘ìš”í•˜ë©´ ëª¨ë‘ í•´ì œ
        const allImportant = selectedMemoObjects.every(memo => memo.isImportant);
        const newImportance = !allImportant;

        // ë©”ëª¨ ì—…ë°ì´íŠ¸
        setMemos(prevMemos =>
            prevMemos.map(memo =>
                selectedMemoIds.has(memo.id)
                    ? { ...memo, isImportant: newImportance }
                    : memo
            )
        );

        showToast(`${selectedMemoIds.size}ê°œì˜ ë©”ëª¨ê°€ ${newImportance ? 'ì¤‘ìš” í‘œì‹œ' : 'ì¤‘ìš” í•´ì œ'}ë˜ì—ˆìŠµë‹ˆë‹¤.`);
        handleExitSelectionMode();
    };

    const handleToggleSelectedMemosStealth = () => {
        if (selectedMemoIds.size === 0) return;

        // ì„ íƒëœ ë©”ëª¨ ê°ì²´ë“¤ ê°€ì ¸ì˜¤ê¸°
        const selectedMemoObjects = memos.filter(memo => selectedMemoIds.has(memo.id));

        // ì„ íƒëœ ë©”ëª¨ ì¤‘ í•˜ë‚˜ë¼ë„ ìŠ¤í…”ìŠ¤ê°€ ì•„ë‹ˆë©´ ëª¨ë‘ ìŠ¤í…”ìŠ¤ë¡œ, ëª¨ë‘ ìŠ¤í…”ìŠ¤ë©´ ëª¨ë‘ í•´ì œ
        const allStealth = selectedMemoObjects.every(memo => memo.isStealth);
        const newStealth = !allStealth;

        // ë©”ëª¨ ì—…ë°ì´íŠ¸
        setMemos(prevMemos =>
            prevMemos.map(memo => {
                if (selectedMemoIds.has(memo.id)) {
                    if (newStealth) {
                        // ìŠ¤í…”ìŠ¤ ì„¤ì •: ëœë¤ ë”ë¯¸ ë¬¸êµ¬ í• ë‹¹
                        return {
                            ...memo,
                            isStealth: true,
                            stealthPhrase: getRandomStealthPhrase()
                        };
                    } else {
                        // ìŠ¤í…”ìŠ¤ í•´ì œ
                        return {
                            ...memo,
                            isStealth: false,
                            stealthPhrase: undefined
                        };
                    }
                }
                return memo;
            })
        );

        showToast(`${selectedMemoIds.size}ê°œì˜ ë©”ëª¨ê°€ ${newStealth ? 'ìŠ¤í…”ìŠ¤ ì„¤ì •' : 'ìŠ¤í…”ìŠ¤ í•´ì œ'}ë˜ì—ˆìŠµë‹ˆë‹¤.`);
        handleExitSelectionMode();
    };

    // ë©”ëª¨ í´ë” ë³€ê²½
    const handleUpdateMemoFolder = (memoId, folderId, savePrevious = false) => {
        setMemos(prevMemos =>
            prevMemos.map(memo => {
                if (memo.id === memoId) {
                    const updates = { folderId };
                    // ê³µìœ  í´ë”ë¡œ ì´ë™í•  ë•Œ ì›ë˜ í´ë” ì •ë³´ ì €ì¥
                    if (savePrevious && folderId === 'shared') {
                        updates.previousFolderId = memo.folderId || null;
                    }
                    return { ...memo, ...updates };
                }
                return memo;
            })
        );
        quietSync(); // ë³€ê²½ì‚¬í•­ ë™ê¸°í™”
    };

    // ë©”ëª¨ í´ë” ë³µì› (ê³µìœ  í•´ì œ ì‹œ)
    const handleRestoreMemoFolder = (memoId) => {
        setMemos(prevMemos =>
            prevMemos.map(memo => {
                if (memo.id === memoId) {
                    // previousFolderIdê°€ ìˆìœ¼ë©´ ë³µì›, ì—†ìœ¼ë©´ ë¯¸ë¶„ë¥˜(null)ë¡œ
                    return {
                        ...memo,
                        folderId: memo.previousFolderId || null,
                        previousFolderId: undefined // ë³µì› í›„ ì œê±°
                    };
                }
                return memo;
            })
        );
        quietSync(); // ë³€ê²½ì‚¬í•­ ë™ê¸°í™”
    };

    // í˜‘ì—…ë°© ì„ íƒ í•¸ë“¤ëŸ¬ (MyWorkspace, RoomBrowserì—ì„œ í˜¸ì¶œ)
    const handleRoomSelect = (room) => {
        console.log('ë°© ì…ì¥:', room);
        setPreviousTab(activeTab); // í˜„ì¬ íƒ­ ì €ì¥
        setSelectedRoomId(room.id);
        setIsCollaborationRoomOpen(true);
    };

    // í˜‘ì—…ë°© ë‹«ê¸° í•¸ë“¤ëŸ¬
    const handleCloseCollaborationRoom = () => {
        setIsCollaborationRoomOpen(false);
        setSelectedRoomId(null);
        // ì´ì „ íƒ­ìœ¼ë¡œ ë³µê·€
        if (previousTab) {
            setActiveTab(previousTab);
            setPreviousTab(null);
        }
    };

    const requestDeleteSelectedMemos = () => {
        if (selectedMemoIds.size === 0) return;
        const idsToDelete = Array.from(selectedMemoIds);
        console.log("ì‚­ì œ ìš”ì²­ëœ ë©”ëª¨ IDë“¤:", idsToDelete); // â˜…â˜…â˜… ì¶”ê°€
        setMemoToDelete(idsToDelete);
        setIsDeleteModalOpen(true);
    };

    // ì„ íƒëœ ë©”ëª¨ ê³µìœ  í•´ì œ ìš”ì²­
    const requestUnshareSelectedMemos = () => {
        if (selectedMemoIds.size === 0) return;
        setIsUnshareConfirmOpen(true);
    };

    // ì„ íƒëœ ë©”ëª¨ ê³µìœ  í•´ì œ ì‹¤í–‰
    const executeUnshareSelectedMemos = async () => {
        setIsUnshareConfirmOpen(false);

        try {
            const selectedIds = Array.from(selectedMemoIds);

            for (const memoId of selectedIds) {
                // ë©”ëª¨ í´ë” ë³µì› (ê³µìœ  í´ë”ì—ì„œ ì›ë˜ í´ë”ë¡œ)
                handleRestoreMemoFolder(memoId);
            }

            handleExitSelectionMode();
            showToast(`${selectedIds.length}ê°œ ë©”ëª¨ì˜ ê³µìœ ê°€ í•´ì œë˜ì—ˆìŠµë‹ˆë‹¤.`);
        } catch (error) {
            console.error('ê³µìœ  í•´ì œ ì‹¤íŒ¨:', error);
            showToast('ê³µìœ  í•´ì œì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.');
        }
    };

    const handleDeleteConfirm = () => {
        const isBulkDelete = Array.isArray(memoToDelete);
        let message = '';

        if (isBulkDelete) {
            const idsToDelete = new Set(memoToDelete);
            
            // ê° ë©”ëª¨ë¥¼ íœ´ì§€í†µìœ¼ë¡œ ì´ë™
            memos.forEach(memo => {
                if (idsToDelete.has(memo.id)) {
                    const event = new CustomEvent('moveToTrash', {
                        detail: {
                            id: memo.id,
                            type: 'memo',
                            content: memo.content.substring(0, 50) + (memo.content.length > 50 ? '...' : ''),
                            originalData: memo
                        }
                    });
                    window.dispatchEvent(event);
                }
            });
            
            setMemos(prevMemos => prevMemos.filter(memo => !idsToDelete.has(memo.id)));
            message = `${idsToDelete.size}ê°œì˜ ë©”ëª¨ê°€ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤.`;
            handleExitSelectionMode();
        } else {
            const memoBeingDeleted = handleDeleteMemo(memoToDelete);
            message = (memoBeingDeleted && memoBeingDeleted.isImportant)
                ? "ì¤‘ìš” ë©”ëª¨ê°€ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤."
                : "ë©”ëª¨ê°€ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤.";
        }
        
        setIsDeleteModalOpen(false);
        setMemoToDelete(null);
        showToast(message);
    };

    const handleDeleteCancel = () => {
        setIsDeleteModalOpen(false);
        setMemoToDelete(null);
    };

    const requestDeleteConfirmation = (id) => {
        setMemoToDelete(id);
        setIsDeleteModalOpen(true);
    };

    const deleteActivity = (activityId) => {
        setRecentActivities(prevActivities => prevActivities.filter(activity => activity.id !== activityId));
    };

    const allData = [
        { id: 'm1', title: 'ì˜¤ëŠ˜ì˜ í•  ì¼', content: 'ì¥ë³´ê¸°, ìš´ë™í•˜ê¸°', type: 'memo', isSecret: false },
        { id: 'c1', title: 'ì—¬í–‰ ê³„íš', content: 'ì œì£¼ë„ ë§›ì§‘ ë¦¬ìŠ¤íŠ¸, ìˆ™ì†Œ ì˜ˆì•½', type: 'calendar', isSecret: false },
        { id: 'r1', title: 'ì´ë²ˆ ì£¼ ë¦¬ë·°', content: 'í”„ë¡œì íŠ¸ í”¼ë“œë°± ë°˜ì˜', type: 'review', isSecret: false },
        { id: 's1', title: 'ë¹„ë°€ë²ˆí˜¸ ëª©ë¡', content: 'ì¤‘ìš”í•œ ê³„ì • ì •ë³´', type: 'secret', isSecret: true },
        { id: 'm2', title: 'React ê³µë¶€', content: 'ì»´í¬ë„ŒíŠ¸ì™€ ìƒíƒœ ê´€ë¦¬ì— ëŒ€í•´ ë³µìŠµí•˜ê¸°', type: 'memo', isSecret: false },
        { id: 'm3', title: 'ì•„ì´ë””ì–´ êµ¬ìƒ', content: 'ìƒˆë¡œìš´ ì•± ì„œë¹„ìŠ¤ì— ëŒ€í•œ ì•„ì´ë””ì–´ ìŠ¤ì¼€ì¹˜', type: 'memo', isSecret: false },
    ];

    const handleSwitchTab = (tab) => {
        setActiveTab(tab);
        // íƒ­ ì „í™˜ ì‹œ ë‹¤ì¤‘ì„ íƒ ëª¨ë“œ í•´ì œ
        if (isSelectionMode) {
            setIsSelectionMode(false);
            setSelectedMemoIds(new Set());
        }
    };

    const handleFloatingButtonClick = () => {
        setIsSearchModalOpen(true);
    };

    const handleToggleMenu = () => {
        setIsMenuOpen(!isMenuOpen);
    };

    const handleSearchClick = () => {
        setIsSearchModalOpen(true);
    };

    const onDragStart = (event) => {
        setActiveId(event.active.id);
    };

    const onDragEnd = (event) => {
        const { active, over } = event;
        if (active.id !== over.id) {
            setWidgets((items) => {
                const oldIndex = items.findIndex((item) => item === active.id);
                const newIndex = items.findIndex((item) => item === over.id);
                return arrayMove(items, oldIndex, newIndex);
            });
        }
        
        setActiveId(null);
    };

    const onDragCancel = () => {
        setActiveId(null); // â˜…â˜…â˜… ì´ ë¶€ë¶„ë„ í˜¹ì‹œ í•„ìš”í•˜ë‹¤ë©´ ì¶”ê°€í•´ ì£¼ì„¸ìš”. (ë“œë˜ê·¸ ì·¨ì†Œ ì‹œ) â˜…â˜…â˜…
    };
    
    const [showHeader, setShowHeader] = useState(true);
    const lastScrollY = useRef(0);
    const scrollDirection = useRef('down');
    const [isSyncing, setIsSyncing] = useState(false);
    const [activeId, setActiveId] = useState(null);

    const mouseSensor = useSensor(MouseSensor, { activationConstraint: { distance: 8 } });
    const touchSensor = useSensor(TouchSensor, { activationConstraint: { delay: 500, tolerance: 5 } });
    const sensors = useSensors(mouseSensor, touchSensor);

    // âœ… GAPI ì´ˆê¸°í™” (ì•± ì‹œì‘ ì‹œ í•œ ë²ˆë§Œ)
    useEffect(() => {
        initializeGapiClient()
            .then(() => {
                console.log('âœ… GAPI ì¤€ë¹„ ì™„ë£Œ');
                setIsGapiReady(true);
            })
            .catch((error) => {
                console.error('âŒ GAPI ì´ˆê¸°í™” ì‹¤íŒ¨:', error);
            });
    }, []);

    // âœ… ì•± ì‹œì‘ ì‹œ ì €ì¥ëœ ì •ë³´ ë³µì› (ê¸°ì¡´ useEffectë¥¼ í™•ì¥)
    useEffect(() => {
        const savedProfile = localStorage.getItem('userProfile');
        const savedToken = localStorage.getItem('accessToken');
        const savedTokenExpiresAt = localStorage.getItem('tokenExpiresAt');
        const savedNickname = localStorage.getItem('userNickname');
        const savedCustomPicture = localStorage.getItem('customProfilePicture');

        if (savedProfile) {
            // í”„ë¡œí•„ì€ í•­ìƒ ë³µì› (ë¡œê·¸ì¸ ìƒíƒœ ìœ ì§€)
            const profileData = JSON.parse(savedProfile);

            // ì €ì¥ëœ ë‹‰ë„¤ì„ì´ ìˆìœ¼ë©´ profileì— ì¶”ê°€
            if (savedNickname) {
                profileData.nickname = savedNickname;
            }
            // ì €ì¥ëœ ì»¤ìŠ¤í…€ í”„ë¡œí•„ ì‚¬ì§„ì´ ìˆìœ¼ë©´ ì¶”ê°€
            if (savedCustomPicture) {
                profileData.customPicture = savedCustomPicture;
            }

            setProfile(profileData);

            // í† í° ê²€ì¦ ë° ì„¤ì •
            if (savedToken && savedTokenExpiresAt) {
                const expiresAt = parseInt(savedTokenExpiresAt, 10);
                const now = Date.now();

                // í† í°ì´ ë§Œë£Œë˜ì—ˆëŠ”ì§€ í™•ì¸ (5ë¶„ ì—¬ìœ ë¥¼ ë‘ )
                if (now >= expiresAt - 5 * 60 * 1000) {
                    console.log('âš ï¸ ì €ì¥ëœ í† í°ì´ ë§Œë£Œë˜ì—ˆìŠµë‹ˆë‹¤. ë™ê¸°í™” ì‹œ ì¬ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤.');
                    // ë§Œë£Œëœ í† í°ë§Œ ì‚­ì œ (í”„ë¡œí•„ì€ ìœ ì§€)
                    localStorage.removeItem('accessToken');
                    localStorage.removeItem('tokenExpiresAt');
                    setAccessTokenState(null);
                } else {
                    // í† í°ì´ ìœ íš¨í•¨
                    console.log('âœ… ìœ íš¨í•œ í† í°ìœ¼ë¡œ ë³µì›ë¨');
                    setAccessTokenState(savedToken);

                    // GAPIê°€ ì¤€ë¹„ë˜ë©´ í† í° ì„¤ì •
                    if (isGapiReady) {
                        setAccessToken(savedToken);
                    }
                }
            } else {
                console.log('âš ï¸ í† í°ì´ ì—†ìŠµë‹ˆë‹¤. ë™ê¸°í™” ì‹œ ì¬ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤.');
                setAccessTokenState(null);
            }
        }

        setIsLoading(false);
    }, [isGapiReady]);

    // âœ… ë‹‰ë„¤ì„ ë³€ê²½ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ
    useEffect(() => {
        const handleNicknameChanged = (event) => {
            const newNickname = event.detail;
            console.log('ğŸ”” ë‹‰ë„¤ì„ ë³€ê²½ ì´ë²¤íŠ¸ ìˆ˜ì‹ :', newNickname);

            setProfile(prevProfile => {
                if (!prevProfile) return prevProfile;
                return {
                    ...prevProfile,
                    nickname: newNickname
                };
            });
        };

        window.addEventListener('nicknameChanged', handleNicknameChanged);

        return () => {
            window.removeEventListener('nicknameChanged', handleNicknameChanged);
        };
    }, []);

    // âœ… í”„ë¡œí•„ ì‚¬ì§„ ë³€ê²½ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ
    useEffect(() => {
        const handleProfilePictureChanged = (event) => {
            const { picture } = event.detail;
            console.log('ğŸ“¸ í”„ë¡œí•„ ì‚¬ì§„ ë³€ê²½ ì´ë²¤íŠ¸ ìˆ˜ì‹ ');

            setProfile(prevProfile => {
                if (!prevProfile) return prevProfile;
                return {
                    ...prevProfile,
                    customPicture: picture
                };
            });
        };

        window.addEventListener('profilePictureChanged', handleProfilePictureChanged);

        return () => {
            window.removeEventListener('profilePictureChanged', handleProfilePictureChanged);
        };
    }, []);

    // âœ… ë¡œê·¸ì¸ ì„±ê³µ ì‹œ ì²˜ë¦¬ (ê¸°ì¡´ handleLoginSuccessë¥¼ í™•ì¥)
    const handleLoginSuccess = async (response) => {
        try {
            const { accessToken, userInfo, expiresAt } = response;

            // â˜…â˜…â˜… ìˆ˜ì •: ê°•ë ¥í•œ URL HTTPS ê°•ì œ ë³€í™˜ ë¡œì§ â˜…â˜…â˜…
            let pictureUrl = userInfo.picture;
            if (pictureUrl) {
                // http:// ë˜ëŠ” https:// ë¶€ë¶„ì„ ì œê±°í•˜ê³  ë¬´ì¡°ê±´ https://ë¥¼ ë¶™ì…ë‹ˆë‹¤.
                const strippedUrl = pictureUrl.replace(/^https?:\/\//, '');
                pictureUrl = `https://${strippedUrl}`;
            }
            // â˜…â˜…â˜…

            // ğŸ”¥ Firebase Authì— Google credentialë¡œ ë¡œê·¸ì¸ (Firestore ê¶Œí•œìš©)
            let firebaseUserId;
            try {
                const credential = GoogleAuthProvider.credential(null, accessToken);
                const userCredential = await signInWithCredential(auth, credential);
                firebaseUserId = userCredential.user.uid;
                console.log('âœ… Firebase Auth ë¡œê·¸ì¸ ì„±ê³µ - uid:', firebaseUserId);
            } catch (firebaseError) {
                console.warn('âš ï¸ Firebase Auth ë¡œê·¸ì¸ ì‹¤íŒ¨, ëŒ€ì²´ ID ì‚¬ìš©:', firebaseError);
                // Firebase Auth ì‹¤íŒ¨ ì‹œ ëŒ€ì²´ ID ì‚¬ìš©
                firebaseUserId = userInfo.sub || userInfo.id || btoa(userInfo.email).replace(/[^a-zA-Z0-9]/g, '').substring(0, 28);
            }

            // ì‚¬ìš©ì í”„ë¡œí•„ ì„¤ì •
            const profileData = {
                email: userInfo.email,
                name: userInfo.name,
                picture: pictureUrl, // ìˆ˜ì •ëœ pictureUrl ì‚¬ìš©
            };

            setProfile(profileData);
            setAccessTokenState(accessToken);

            localStorage.setItem('userProfile', JSON.stringify(profileData));
            localStorage.setItem('accessToken', accessToken);
            localStorage.setItem('tokenExpiresAt', expiresAt.toString()); // í† í° ë§Œë£Œ ì‹œê°„ ì €ì¥
            localStorage.setItem('firebaseUserId', firebaseUserId); // ğŸ”¥ í˜‘ì—… ê¸°ëŠ¥ìš© ì‚¬ìš©ì ID ì €ì¥

            console.log('âœ… ë¡œê·¸ì¸ ì™„ë£Œ - firebaseUserId:', firebaseUserId);

            // ğŸ“Š Analytics ì‚¬ìš©ì ID ë° ì†ì„± ì„¤ì •
            try {
                const { setAnalyticsUserId, setAnalyticsUserProperties, logLoginEvent } = await import('./utils/analyticsUtils.js');
                setAnalyticsUserId(firebaseUserId);
                setAnalyticsUserProperties({
                    user_name: userInfo.name,
                    user_email: userInfo.email,
                });
                logLoginEvent('google');
            } catch (analyticsError) {
                console.warn('âš ï¸ Analytics ì„¤ì • ì˜¤ë¥˜:', analyticsError);
            }

            // ğŸ‘¤ ì‚¬ìš©ì ë¬¸ì„œ ìƒì„±/ì—…ë°ì´íŠ¸ (users ì»¬ë ‰ì…˜)
            try {
                const userRef = doc(db, 'users', firebaseUserId);
                const userDoc = await getDoc(userRef);

                const userData = {
                    displayName: userInfo.name,
                    email: userInfo.email,
                    photoURL: pictureUrl,
                    updatedAt: Date.now()
                };

                if (!userDoc.exists()) {
                    // ìƒˆ ì‚¬ìš©ì ë¬¸ì„œ ìƒì„±
                    await setDoc(userRef, {
                        ...userData,
                        createdAt: Date.now()
                    });
                    console.log('âœ… ì‚¬ìš©ì ë¬¸ì„œ ìƒì„± ì™„ë£Œ');
                } else {
                    // ê¸°ì¡´ ì‚¬ìš©ì ì •ë³´ ì—…ë°ì´íŠ¸
                    await updateDoc(userRef, userData);
                    console.log('âœ… ì‚¬ìš©ì ì •ë³´ ì—…ë°ì´íŠ¸ ì™„ë£Œ');
                }
            } catch (userError) {
                console.error('âš ï¸ ì‚¬ìš©ì ë¬¸ì„œ ìƒì„±/ì—…ë°ì´íŠ¸ ì˜¤ë¥˜:', userError);
            }

            // ğŸ  ì›Œí¬ìŠ¤í˜ì´ìŠ¤ ìë™ ìƒì„± (ì—†ìœ¼ë©´ ìƒì„±)
            try {
                const workspaceExists = await checkWorkspaceExists(firebaseUserId);
                if (!workspaceExists) {
                    console.log('ğŸ—ï¸ ì›Œí¬ìŠ¤í˜ì´ìŠ¤ê°€ ì—†ìŠµë‹ˆë‹¤. ìë™ ìƒì„± ì¤‘...');
                    await createWorkspace(firebaseUserId, userInfo.name, userInfo.email);
                    console.log('âœ… ì›Œí¬ìŠ¤í˜ì´ìŠ¤ ìë™ ìƒì„± ì™„ë£Œ');
                } else {
                    console.log('âœ… ê¸°ì¡´ ì›Œí¬ìŠ¤í˜ì´ìŠ¤ ì¡´ì¬');
                }
            } catch (workspaceError) {
                console.error('âš ï¸ ì›Œí¬ìŠ¤í˜ì´ìŠ¤ ìƒì„± ì˜¤ë¥˜ (ë¡œê·¸ì¸ì€ ê³„ì†):', workspaceError);
                // ì›Œí¬ìŠ¤í˜ì´ìŠ¤ ìƒì„± ì‹¤íŒ¨í•´ë„ ë¡œê·¸ì¸ì€ ê³„ì† ì§„í–‰
            }

            // GAPIì— í† í° ì„¤ì •
            if (isGapiReady) {
                console.log('ğŸ”‘ ë¡œê·¸ì¸ ì„±ê³µ - GAPIì— í† í° ì„¤ì •');
                setAccessToken(accessToken);
                // í† í° ì„¤ì • í›„ ì§§ì€ ëŒ€ê¸° ì‹œê°„ (GAPI ë‚´ë¶€ ì²˜ë¦¬ ëŒ€ê¸°)
                await new Promise(resolve => setTimeout(resolve, 200));
                console.log('âœ… GAPI í† í° ì„¤ì • ì™„ë£Œ');
            } else {
                console.warn('âš ï¸ GAPIê°€ ì•„ì§ ì¤€ë¹„ë˜ì§€ ì•ŠìŒ - í† í°ì€ ì €ì¥ë¨');
            }

            setIsLoginModalOpen(false);
            showToast('âœ“ ë¡œê·¸ì¸ë˜ì—ˆìŠµë‹ˆë‹¤');
        } catch (error) {
            console.error('ë¡œê·¸ì¸ ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜:', error);
            showToast('âš  ë¡œê·¸ì¸ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤');
        }
    };

    const handleLoginError = () => {
        console.log('Login Failed');
        setIsLoginModalOpen(false);
    };

    // âœ… í† í° ìë™ ê°±ì‹  ì²´í¬ (í† í° ë§Œë£Œ 10ë¶„ ì „ì— í™•ì¸)
    useEffect(() => {
        if (!accessToken) return;

        const checkTokenExpiry = () => {
            const expiresAtStr = localStorage.getItem('tokenExpiresAt');
            if (!expiresAtStr) return;

            const expiresAt = parseInt(expiresAtStr, 10);
            const now = Date.now();
            const timeUntilExpiry = expiresAt - now;

            // í† í°ì´ 10ë¶„ ì´ë‚´ì— ë§Œë£Œë  ì˜ˆì •
            if (timeUntilExpiry < 10 * 60 * 1000 && timeUntilExpiry > 0) {
                console.log(`â° í† í°ì´ ${Math.floor(timeUntilExpiry / 1000 / 60)}ë¶„ í›„ ë§Œë£Œ ì˜ˆì • - ìë™ ê°±ì‹  í•„ìš”`);
                // í† í° ì‚­ì œí•˜ì—¬ ë‹¤ìŒ ë™ê¸°í™” ì‹œ ì¬ë¡œê·¸ì¸ ìœ ë„
                localStorage.removeItem('accessToken');
                localStorage.removeItem('tokenExpiresAt');
                setAccessTokenState(null);
                console.log('ğŸ” í† í° ì œê±°ë¨ - ë‹¤ìŒ ë™ê¸°í™” ì‹œ ì¬ë¡œê·¸ì¸ í•„ìš”');
            } else if (timeUntilExpiry <= 0) {
                console.log('âŒ í† í°ì´ ì´ë¯¸ ë§Œë£Œë¨ - ì œê±°');
                localStorage.removeItem('accessToken');
                localStorage.removeItem('tokenExpiresAt');
                setAccessTokenState(null);
            }
        };

        // ì´ˆê¸° ì²´í¬
        checkTokenExpiry();

        // 5ë¶„ë§ˆë‹¤ ì²´í¬
        const interval = setInterval(checkTokenExpiry, 5 * 60 * 1000);

        return () => clearInterval(interval);
    }, [accessToken]);

    // âœ… handleSync í•¨ìˆ˜ (performSync(true) í˜¸ì¶œ í™•ì¸)
    const handleSync = async () => {
        console.log('ğŸ”„ handleSync í˜¸ì¶œë¨');
        console.log('ğŸ‘¤ profile:', profile);
        console.log('ğŸ”‘ accessToken:', accessToken ? 'ìˆìŒ' : 'ì—†ìŒ');
        console.log('ğŸ“¡ isGapiReady:', isGapiReady);
        
        await performSync(true);
    };

    const quietSync = () => {
        // ê¸°ì¡´ íƒ€ì´ë¨¸ í´ë¦¬ì–´
        if (syncDebounceRef.current) {
            clearTimeout(syncDebounceRef.current);
        }
        
        // 3ì´ˆ í›„ ì¡°ìš©íˆ ë™ê¸°í™”
        syncDebounceRef.current = setTimeout(async () => {
            if (profile && accessToken && isGapiReady) {
                console.log('ğŸ”„ ì¡°ìš©í•œ ë™ê¸°í™” ì‹œì‘ (3ì´ˆ ë””ë°”ìš´ì‹±)');
                await performSync(false); // isManual = false (ë©”ì‹œì§€ ì—†ìŒ)
            }
        }, 3000); // 3ì´ˆ
    };

    const performSync = async (isManual = false) => {
        console.log('ğŸ”§ performSync ì‹œì‘ - isManual:', isManual);

        if (!profile || !accessToken) {
            console.log('âŒ ë¡œê·¸ì¸ ì•ˆ ë¨');
            if (isManual) {
                showToast('ğŸ” ë¡œê·¸ì¸ ì„¸ì…˜ì´ ë§Œë£Œë˜ì—ˆìŠµë‹ˆë‹¤');
                console.log('Toast í‘œì‹œ: ë¡œê·¸ì¸ ì„¸ì…˜ì´ ë§Œë£Œë˜ì—ˆìŠµë‹ˆë‹¤');
                // 1.5ì´ˆ í›„ ë¡œê·¸ì¸ ëª¨ë‹¬ í‘œì‹œ
                setTimeout(() => {
                    setIsLoginModalOpen(true);
                }, 1500);
            }
            return false;
        }

        if (!isGapiReady) {
            console.log('âŒ GAPI ì¤€ë¹„ ì•ˆ ë¨');
            if (isManual) {
                showToast('â³ Drive ì—°ê²° ì¤‘...');
                console.log('Toast í‘œì‹œ: Drive ì—°ê²° ì¤‘');
            }
            return false;
        }

        try {
            console.log('âœ… ë™ê¸°í™” ì¡°ê±´ ì¶©ì¡± - ì‹œì‘');

            // ğŸ”‘ ë™ê¸°í™” ì „ì— GAPIì— í† í° ì¬ì„¤ì • (íƒ€ì´ë° ì´ìŠˆ ë°©ì§€)
            console.log('ğŸ”‘ GAPIì— í† í° ì¬ì„¤ì • ì¤‘...');
            setAccessToken(accessToken);
            await new Promise(resolve => setTimeout(resolve, 100)); // GAPI í† í° ì„¤ì • ëŒ€ê¸°
            
            if (isManual) {
                console.log('ğŸ¯ ìˆ˜ë™ ë™ê¸°í™” - ìŠ¤í”¼ë„ˆ í‘œì‹œ');
                setIsSyncing(true);
                // ë™ê¸°í™” ì‹œì‘ í† ìŠ¤íŠ¸ ì œê±° - ìŠ¤í”¼ë„ˆë§Œ í‘œì‹œ
                await new Promise(resolve => setTimeout(resolve, 300));
            }
            
            const dataToSync = {
                memos,
                calendarSchedules,
                recentActivities,
                displayCount,
                widgets,
                trashedItems: JSON.parse(localStorage.getItem('trashedItems_shared') || '[]'),
                macroTexts: JSON.parse(localStorage.getItem('macroTexts') || '[]'),
                memoFolders: JSON.parse(localStorage.getItem('memoFolders') || '[]'),
                userEmail: profile.email,
            };

            console.log('ğŸ“¤ Google Driveì— ì—…ë¡œë“œ ì‹œì‘...');
            const result = await syncToGoogleDrive(dataToSync);
            console.log('ğŸ“¥ ì—…ë¡œë“œ ê²°ê³¼:', result);

            if (result.success) {
                // âœ… ì„±ê³µ ì²˜ë¦¬ - ì´ ë¶€ë¶„ì´ ë°˜ë“œì‹œ ìˆì–´ì•¼ í•¨!
                const now = Date.now();
                setLastSyncTime(now);
                localStorage.setItem('lastSyncTime', now.toString());

                if (isManual) {
                    console.log('âœ… ìˆ˜ë™ ë™ê¸°í™” - í™œë™ ê¸°ë¡ ì¶”ê°€');
                    addActivity('ë™ê¸°í™”', 'Google Drive ë™ê¸°í™” ì™„ë£Œ');
                    await new Promise(resolve => setTimeout(resolve, 500));
                    console.log('âœ… ìˆ˜ë™ ë™ê¸°í™” - í† ìŠ¤íŠ¸ í‘œì‹œ');
                    showToast('âœ… ë™ê¸°í™” ì™„ë£Œ!');
                    console.log('Toast í‘œì‹œ: ë™ê¸°í™” ì™„ë£Œ');
                }
                return true;
            } else {
                console.error('âŒ ë™ê¸°í™” ì‹¤íŒ¨:', result);
                if (result.error === 'TOKEN_EXPIRED') {
                    // âœ… í† í° ë§Œë£Œ - í† í°ë§Œ ì‚­ì œí•˜ê³  ì¬ë¡œê·¸ì¸ ìœ ë„
                    console.log('ğŸ”„ í† í° ë§Œë£Œ ê°ì§€ - í† í° ì‚­ì œ');
                    localStorage.removeItem('accessToken');
                    localStorage.removeItem('tokenExpiresAt');
                    setAccessTokenState(null);

                    if (isManual) {
                        showToast('ğŸ” ë¡œê·¸ì¸ ì„¸ì…˜ì´ ë§Œë£Œë˜ì—ˆìŠµë‹ˆë‹¤. ë‹¤ì‹œ ë¡œê·¸ì¸í•´ì£¼ì„¸ìš”.');
                        setTimeout(() => {
                            setIsLoginModalOpen(true);
                        }, 1500);
                    }
                } else {
                    if (isManual) {
                        showToast('âŒ ë™ê¸°í™” ì‹¤íŒ¨');
                    }
                }
                return false;
            }
        } catch (error) {
            console.error('âŒ ë™ê¸°í™” ì¤‘ ì˜¤ë¥˜:', error);
            if (isManual) showToast('âŒ ì˜¤ë¥˜ ë°œìƒ');
            return false;
        } finally {
            if (isManual) {
                console.log('ğŸ¯ ìˆ˜ë™ ë™ê¸°í™” - ìŠ¤í”¼ë„ˆ ìˆ¨ê¹€');
                setIsSyncing(false);
            }
        }
    };

    useEffect(() => {
        const handleVisibilityChange = async () => {
            console.log('ğŸ”” Visibility ìƒíƒœ ë³€ê²½:', document.hidden ? 'ìˆ¨ê¹€(ë°±ê·¸ë¼ìš´ë“œ)' : 'ë³´ì„(í¬ê·¸ë¼ìš´ë“œ)');
            
            if (document.hidden) {
                // ì•±ì´ ë°±ê·¸ë¼ìš´ë“œë¡œ ì „í™˜ë¨
                console.log('ğŸ“± ë°±ê·¸ë¼ìš´ë“œ ì „í™˜ ê°ì§€ - ì¦‰ì‹œ ë™ê¸°í™” ì‹œì‘');
                
                // ëŒ€ê¸° ì¤‘ì¸ ë””ë°”ìš´ìŠ¤ íƒ€ì´ë¨¸ ì·¨ì†Œ
                if (syncDebounceRef.current) {
                    clearTimeout(syncDebounceRef.current);
                    console.log('â¸ï¸ ë””ë°”ìš´ìŠ¤ íƒ€ì´ë¨¸ ì·¨ì†Œë¨');
                }
                
                // ì¦‰ì‹œ ë™ê¸°í™” (ì¡°ìš©íˆ)
                if (profile && accessToken && isGapiReady) {
                    console.log('ğŸ”„ ë°±ê·¸ë¼ìš´ë“œ ë™ê¸°í™” ì‹¤í–‰ ì¤‘...');
                    const success = await performSync(false); // isManual = false
                    if (success) {
                        console.log('âœ… ë°±ê·¸ë¼ìš´ë“œ ë™ê¸°í™” ì™„ë£Œ');
                    }
                }
            } else {
                // ì•±ì´ í¬ê·¸ë¼ìš´ë“œë¡œ ë³µê·€
                console.log('ğŸ‘€ ì•±ì´ ë‹¤ì‹œ í™œì„±í™”ë¨ (í¬ê·¸ë¼ìš´ë“œ)');
            }
        };
        
        document.addEventListener('visibilitychange', handleVisibilityChange);
        
        return () => {
            document.removeEventListener('visibilitychange', handleVisibilityChange);
        };
    }, [profile, accessToken, isGapiReady, memos, calendarSchedules, recentActivities, displayCount, widgets]);

    // Pull-to-refreshì—ì„œ Google Drive ë™ê¸°í™” íŠ¸ë¦¬ê±°
    useEffect(() => {
        const handleTriggerSync = async () => {
            console.log('ğŸ”„ Pull-to-refreshì—ì„œ ë™ê¸°í™” íŠ¸ë¦¬ê±°ë¨');
            if (profile && accessToken && isGapiReady) {
                await performSync(true); // ìˆ˜ë™ ë™ê¸°í™”ë¡œ ì²˜ë¦¬ (í† ìŠ¤íŠ¸ ë©”ì‹œì§€ í‘œì‹œ)
            } else {
                console.log('âŒ ë™ê¸°í™” ì¡°ê±´ ë¯¸ì¶©ì¡± - profile:', !!profile, 'accessToken:', !!accessToken, 'isGapiReady:', isGapiReady);
            }
        };

        window.addEventListener('triggerGoogleDriveSync', handleTriggerSync);

        return () => {
            window.removeEventListener('triggerGoogleDriveSync', handleTriggerSync);
        };
    }, [profile, accessToken, isGapiReady, memos, calendarSchedules, recentActivities, displayCount, widgets]);

    // âœ… ì•± ì¢…ë£Œ ì‹œ ë§ˆì§€ë§‰ ë™ê¸°í™” - ìƒˆë¡œ ì¶”ê°€
    useEffect(() => {
        const handleBeforeUnload = async () => {
            if (profile && accessToken && isGapiReady) {
                console.log('ğŸ‘‹ ì•± ì¢…ë£Œ ì „ ë§ˆì§€ë§‰ ë™ê¸°í™”...');
                
                const dataToSync = {
                    memos,
                    calendarSchedules,
                    recentActivities,
                    displayCount,
                    widgets,
                    trashedItems: JSON.parse(localStorage.getItem('trashedItems_shared') || '[]'),
                    memoFolders: JSON.parse(localStorage.getItem('memoFolders') || '[]'),
                    userEmail: profile.email,
                };

                try {
                    await syncToGoogleDrive(dataToSync);
                    console.log('âœ… ì¢…ë£Œ ì „ ë™ê¸°í™” ì™„ë£Œ');
                } catch (error) {
                    console.error('âŒ ì¢…ë£Œ ì „ ë™ê¸°í™” ì‹¤íŒ¨:', error);
                }
            }
        };

        window.addEventListener('beforeunload', handleBeforeUnload);
        
        return () => {
            window.removeEventListener('beforeunload', handleBeforeUnload);
        };
    }, [profile, accessToken, isGapiReady, memos, calendarSchedules, recentActivities]);

    // âœ… Google Driveì—ì„œ ë³µì› - ìƒˆë¡œ ì¶”ê°€
    const handleRestoreFromDrive = async () => {
        if (!profile || !accessToken) {
            showToast('âš  ë¡œê·¸ì¸ì´ í•„ìš”í•©ë‹ˆë‹¤');
            setIsLoginModalOpen(true);
            return;
        }

        if (!isGapiReady) {
            showToast('â³ Drive ì—°ê²° ì¤€ë¹„ ì¤‘...');
            return;
        }

        // í™•ì¸ ëª¨ë‹¬ í‘œì‹œ
        setRestoreType('google');
        setIsRestoreConfirmOpen(true);
    };

    const executeGoogleDriveRestore = async () => {
        try {
            const result = await loadFromGoogleDrive();

            if (result.success && result.data) {
                if (result.data.memos) setMemos(result.data.memos);
                if (result.data.calendarSchedules) setCalendarSchedules(result.data.calendarSchedules);
                if (result.data.recentActivities) setRecentActivities(result.data.recentActivities);
                if (result.data.displayCount) setDisplayCount(result.data.displayCount);
                if (result.data.widgets) setWidgets(result.data.widgets);
                if (result.data.trashedItems) {
                    localStorage.setItem('trashedItems_shared', JSON.stringify(result.data.trashedItems));
                }
                if (result.data.macroTexts) {
                    localStorage.setItem('macroTexts', JSON.stringify(result.data.macroTexts));
                }
                if (result.data.memoFolders) {
                    localStorage.setItem('memoFolders', JSON.stringify(result.data.memoFolders));
                }

                addActivity('ë³µì›', 'Google Driveì—ì„œ ë³µì› ì™„ë£Œ');
                showToast('âœ“ ë°ì´í„°ê°€ ë³µì›ë˜ì—ˆìŠµë‹ˆë‹¤');

                setIsMenuOpen(false);
            } else if (result.message === 'NO_FILE') {
                showToast('âš  ë³µì›í•  ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤');
            } else if (result.error === 'TOKEN_EXPIRED') {
                showToast('âš  ë¡œê·¸ì¸ì´ ë§Œë£Œë˜ì—ˆìŠµë‹ˆë‹¤');
                handleLogout();
            } else {
                showToast('âš  ë³µì›ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤');
            }
        } catch (error) {
            console.error('ë³µì› ì¤‘ ì˜¤ë¥˜:', error);
            showToast('âš  ë³µì› ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤');
        }

        // ì´ˆê¸°í™”
        setIsRestoreConfirmOpen(false);
    };

    // âœ… ë¡œê·¸ì•„ì›ƒ (í™•ì¥ë¨)
    const handleLogout = async () => {
        // ğŸ”¥ Firebase Auth ë¡œê·¸ì•„ì›ƒ
        try {
            if (auth) {
                await signOut(auth);
                console.log('ğŸ”¥ Firebase ë¡œê·¸ì•„ì›ƒ ì™„ë£Œ');
            }
        } catch (error) {
            console.error('Firebase ë¡œê·¸ì•„ì›ƒ ì˜¤ë¥˜:', error);
        }

        setProfile(null);
        setAccessTokenState(null);
        localStorage.removeItem('userProfile');
        localStorage.removeItem('accessToken');
        localStorage.removeItem('lastSyncTime');
        localStorage.removeItem('firebaseUserId'); // ğŸ”¥ í˜‘ì—… ê¸°ëŠ¥ìš© ì‚¬ìš©ì ID ì œê±°

        showToast("âœ“ ë¡œê·¸ì•„ì›ƒë˜ì—ˆìŠµë‹ˆë‹¤");
        setIsMenuOpen(false);

        // ìë™ ë™ê¸°í™” ì¤‘ì§€
        if (syncIntervalRef.current) {
            clearInterval(syncIntervalRef.current);
        }
    };
    
    useEffect(() => {
        console.log('ğŸ” showHeader ìƒíƒœ ë³€ê²½:', showHeader);
    }, [showHeader]);

    const lastScrollYRef = useRef(0);
    
    // â˜…â˜…â˜… ìŠ¤í¬ë¡¤ ì„ê³„ê°’ ë³€ìˆ˜ë¥¼ ì •ì˜í•©ë‹ˆë‹¤. â˜…â˜…â˜…
    const HIDE_THRESHOLD = 80; // ì´ ê°’ ì´ìƒ ìŠ¤í¬ë¡¤í•´ì•¼ í—¤ë”ê°€ ìˆ¨ê²¨ì§‘ë‹ˆë‹¤.
    const SHOW_THRESHOLD = 5; // ì´ ê°’ ì´í•˜ë¡œ ìŠ¤í¬ë¡¤í•´ì•¼ í—¤ë”ê°€ ë‹¤ì‹œ ë‚˜íƒ€ë‚©ë‹ˆë‹¤.

    useEffect(() => {
    const handleScroll = () => {
        const currentY = contentAreaRef.current.scrollTop;

        // 1. ìŠ¤í¬ë¡¤ ë‹¤ìš´ (ìˆ¨ê¸°ê¸°) ë¡œì§
        // í˜„ì¬ ìŠ¤í¬ë¡¤ ìœ„ì¹˜ê°€ ì´ì „ì— ì €ì¥ëœ ê°’ë³´ë‹¤ í¬ê³ , ìˆ¨ê¹€ ì„ê³„ê°’ë³´ë‹¤ í¬ë©´ ìˆ¨ê¹ë‹ˆë‹¤.
        if (currentY > lastScrollYRef.current && currentY > HIDE_THRESHOLD) { 
            setShowHeader(false);
        } 
        // 2. ìŠ¤í¬ë¡¤ ì—… (ë³´ì´ê¸°) ë¡œì§
        // í˜„ì¬ ìŠ¤í¬ë¡¤ ìœ„ì¹˜ê°€ ì´ì „ì— ì €ì¥ëœ ê°’ë³´ë‹¤ ì‘ê³ , ë³´ì´ê¸° ì„ê³„ê°’ë³´ë‹¤ ì‘ìœ¼ë©´ ë³´ì´ê²Œ í•©ë‹ˆë‹¤.
        // ìŠ¤í¬ë¡¤ì„ 'ìœ„ë¡œ' ì˜¬ë¦´ ë•Œë§Œ ë°˜ì‘í•˜ë„ë¡ lastScrollYRef.currentë„ ì²´í¬í•©ë‹ˆë‹¤.
        else if (currentY < lastScrollYRef.current && currentY <= SHOW_THRESHOLD) { 
            setShowHeader(true);
        }

        lastScrollYRef.current = currentY; 
    };

    const timer = setTimeout(() => {
        const contentArea = contentAreaRef.current;
        if (contentArea) {
        contentArea.addEventListener('scroll', handleScroll);
        console.log('âœ… ìŠ¤í¬ë¡¤ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ë“±ë¡ë¨');
        }
    }, 100);

    return () => {
        clearTimeout(timer);
        const contentArea = contentAreaRef.current;
        if (contentArea) {
        contentArea.removeEventListener('scroll', handleScroll);
        }
    };
    }, []);

    const executeCalendarDelete = () => {
        if (!dateToDelete) return;
        const key = format(dateToDelete, 'yyyy-MM-dd');
        const deletedEntry = calendarSchedules[key];
    
        if (deletedEntry) {
            // íœ´ì§€í†µìœ¼ë¡œ ì´ë™ ì´ë²¤íŠ¸ ë°œìƒ
            const event = new CustomEvent('moveToTrash', {
                detail: {
                    id: key,
                    type: 'schedule',
                    content: `${key} - ${deletedEntry.text}`,
                    originalData: { date: dateToDelete, ...deletedEntry }
                }
            });
            window.dispatchEvent(event);
            
            // í™œë™ ë‚´ì—­ ì¶”ê°€
            addActivity('ìŠ¤ì¼€ì¤„ ì‚­ì œ', `${key} - ${deletedEntry.text}`);
        }

        setCalendarSchedules(prev => {
            const updated = { ...prev };
            delete updated[key];
            return updated;
        });

        showToast?.('âœ“ ìŠ¤ì¼€ì¤„ì´ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤');
        setIsCalendarConfirmOpen(false);
        setDateToDelete(null);
        quietSync();
    };
    
    const handleTouchStart = (e) => {
        // SecretPageì—ì„œëŠ” Pull-to-refresh ë¹„í™œì„±í™”
        if (activeTab === 'secret') return;
        handlePullStart(e.touches[0].clientY);
    };

    const handleTouchMove = (e) => {
        // SecretPageì—ì„œëŠ” Pull-to-refresh ë¹„í™œì„±í™”
        if (activeTab === 'secret') return;

        if (isDragging && contentAreaRef.current?.scrollTop === 0) {
            // ìŠ¤í¬ë¡¤ ìµœìƒë‹¨ì—ì„œ ë“œë˜ê·¸ ì¤‘ì¼ ë•Œë§Œ ê¸°ë³¸ ë™ì‘ ë°©ì§€
            e.preventDefault();
        }
        handlePullMove(e.touches[0].clientY);
    };

    const handleTouchEnd = async () => {
        // SecretPageì—ì„œëŠ” Pull-to-refresh ë¹„í™œì„±í™”
        if (activeTab === 'secret') return;
        await handlePullEnd();
    };

    const handleTouchCancel = async () => {
        // SecretPageì—ì„œëŠ” Pull-to-refresh ë¹„í™œì„±í™”
        if (activeTab === 'secret') return;
        // í„°ì¹˜ê°€ ì·¨ì†Œë˜ì–´ë„ handlePullEnd í˜¸ì¶œ (ë“œë˜ê·¸ ì¢…ë£Œ)
        await handlePullEnd();
    };

    // ë§ˆìš°ìŠ¤ ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬ (PC ì§€ì›)
    const handleMouseDown = (e) => {
        // SecretPageì—ì„œëŠ” Pull-to-refresh ë¹„í™œì„±í™”
        if (activeTab === 'secret') return;
        handlePullStart(e.clientY);
    };

    const handleMouseMove = (e) => {
        // SecretPageì—ì„œëŠ” Pull-to-refresh ë¹„í™œì„±í™”
        if (activeTab === 'secret') return;
        if (isDragging) {
            handlePullMove(e.clientY);
        }
    };

    const handleMouseUp = async () => {
        // SecretPageì—ì„œëŠ” Pull-to-refresh ë¹„í™œì„±í™”
        if (activeTab === 'secret') return;
        if (isDragging) {
            await handlePullEnd();
        }
    };

    const handleMouseLeave = async () => {
        // SecretPageì—ì„œëŠ” Pull-to-refresh ë¹„í™œì„±í™”
        if (activeTab === 'secret') return;
        if (isDragging) {
            await handlePullEnd();
        }
    };
    
    useEffect(() => {
        if (contentAreaRef.current) {
            contentAreaRef.current.scrollTop = 0;
        }
    }, [activeTab]);
    
    const [loginService, setLoginService] = useState('none');
    const [isLoggedIn, setIsLoggedIn] = useState(false);
    
    // ìƒˆ ë©”ëª¨ ì‘ì„± ì‹œ ì €ì¥í•  í´ë” ID
    const [newMemoFolderId, setNewMemoFolderId] = useState(null);

    const handleOpenNewMemoFromPage = (folderId = null) => {
        setMemoOpenSource('page');
        setNewMemoFolderId(folderId); // í´ë” ID ì €ì¥
        setIsNewMemoModalOpen(true);
    };

    const handleOpenNewMemoFromFAB = () => {
        setMemoOpenSource('fab');
        setNewMemoFolderId(null); // FABì—ì„œ ì—´ ë•ŒëŠ” ë¯¸ë¶„ë¥˜ë¡œ ì €ì¥
        setIsNewMemoModalOpen(true);
    };

    const handleOpenDetailMemo = (memo) => {
        setSelectedMemo(memo);
        setIsDetailModalOpen(true);
    };
    const [selectedDate, setSelectedDate] = useState(new Date()); // ìƒˆë¡œìš´ ìƒíƒœ ì¶”ê°€

    const handleSelectDate = (date) => {
        setSelectedDate(date);
        // ë‚˜ì¤‘ì— ìŠ¤ì¼€ì¤„ ì—ë””í„°ë¥¼ ë Œë”ë§í•˜ëŠ” ë° ì‚¬ìš©ë©ë‹ˆë‹¤.
    };

    useEffect(() => {
        return () => {
            if (syncDebounceRef.current) {
                clearTimeout(syncDebounceRef.current);
            }
        };
    }, []);

    // âœ… íœ´ì§€í†µì—ì„œ ë³µì› ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ
    useEffect(() => {
        const handleRestore = (event) => {
            const restoredItems = event.detail;

            console.log('â™»ï¸ ë³µì› ì´ë²¤íŠ¸ ìˆ˜ì‹ :', restoredItems);

            restoredItems.forEach(item => {
                if (item.type === 'memo') {
                    // ë©”ëª¨ ë³µì›
                    setMemos(prev => [item.originalData, ...prev]);
                    addActivity('ë©”ëª¨ ë³µì›', item.content);
                    console.log('âœ… ë©”ëª¨ ë³µì›ë¨:', item.originalData);
                } else if (item.type === 'schedule') {
                    // ìŠ¤ì¼€ì¤„ ë³µì›
                    const { date, ...scheduleData } = item.originalData;
                    const key = format(new Date(date), 'yyyy-MM-dd');
                    setCalendarSchedules(prev => ({
                        ...prev,
                        [key]: scheduleData
                    }));
                    addActivity('ìŠ¤ì¼€ì¤„ ë³µì›', item.content);
                    console.log('âœ… ìŠ¤ì¼€ì¤„ ë³µì›ë¨:', { key, scheduleData });
                } else if (item.type === 'secret') {
                    // ë¹„ë°€ê¸€ ë³µì› - SecretPageì— ì´ë²¤íŠ¸ ì „ë‹¬
                    const restoreSecretEvent = new CustomEvent('restoreSecret', {
                        detail: item.originalData
                    });
                    window.dispatchEvent(restoreSecretEvent);
                    addActivity('ë¹„ë°€ê¸€ ë³µì›', item.content);
                    console.log('âœ… ë¹„ë°€ê¸€ ë³µì› ì´ë²¤íŠ¸ ë°œì†¡:', item.originalData);
                }
            });

            quietSync();
        };

        window.addEventListener('restoreToApp', handleRestore);
        return () => window.removeEventListener('restoreToApp', handleRestore);
    }, []);

    if (isLoading) {
        return (
            <Screen>
                <LoadingScreen>
                    ì•±ì„ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘...
                </LoadingScreen>
            </Screen>
        );
    }

    return (
        <AppRouter>
            <TrashProvider autoDeleteDays={30}>
                <AppContent>
                    <GlobalStyle />
                <Screen>
                {/* â˜…â˜…â˜… ë” ì´ìƒ ë¡œê·¸ì¸ ì—¬ë¶€ë¡œ í™”ë©´ì„ ë§‰ì§€ ì•Šê³ , í•­ìƒ ë©”ì¸ ì•±ì„ ë³´ì—¬ì¤ë‹ˆë‹¤. â˜…â˜…â˜… */}
                <>
                    <Header
                        key={showHeader.toString()}
                        profile={profile}
                        onLogout={handleLogout}
                        onSearchClick={handleSearchClick}
                        onMenuClick={handleToggleMenu}
                        isHidden={!showHeader}
                        onLoginClick={() => setIsLoginModalOpen(true)}
                        onProfileClick={handleProfileClick}
                    />

                    {/* í’€ ê°€ì´ë“œ ë©”ì‹œì§€: 100px ì´ìƒ ë‹¹ê²¼ì„ ë•Œ í‘œì‹œ */}
                    {!isSyncing && pullDistance >= 110 && (
                        <PullGuideMessage>
                            â†“ ì†ì„ ë–¼ë©´ ë™ê¸°í™”ê°€ ì‹œì‘ë©ë‹ˆë‹¤
                        </PullGuideMessage>
                    )}

                    {/* ë™ê¸°í™” ì¤‘ í‘œì‹œ (ContentArea ë°–ìœ¼ë¡œ ì´ë™) */}
                    {isSyncing && (
                        <PullToSyncIndicator>
                            <SyncSpinner />
                            ë™ê¸°í™” ì¤‘...
                        </PullToSyncIndicator>
                    )}

                    <ContentArea
                        ref={contentAreaRef}
                        $pullDistance={pullDistance}
                        $showHeader={showHeader}
                        $isDragging={isDragging}
                        $isSecretTab={activeTab === 'secret'}
                        // í„°ì¹˜ ì´ë²¤íŠ¸ (ëª¨ë°”ì¼) - ì‹œí¬ë¦¿ í˜ì´ì§€ì—ì„œëŠ” ì™„ì „íˆ ë¹„í™œì„±í™”
                        {...(activeTab !== 'secret' && {
                            onTouchStart: handleTouchStart,
                            onTouchMove: handleTouchMove,
                            onTouchEnd: handleTouchEnd,
                            onTouchCancel: handleTouchCancel,
                            onMouseDown: handleMouseDown,
                            onMouseMove: handleMouseMove,
                            onMouseUp: handleMouseUp,
                            onMouseLeave: handleMouseLeave
                        })}
                    >
                        {activeTab === 'home' && (
                            <DndContext sensors={sensors} collisionDetection={closestCenter} onDragEnd={onDragEnd}>
                                <SortableContext items={widgets} strategy={verticalListSortingStrategy}>
                                    {widgets.map((widgetName) => (
                                        <DraggableWidget
                                            key={widgetName}
                                            id={widgetName}
                                            onSwitchTab={handleSwitchTab}
                                            addActivity={addActivity}
                                            recentActivities={recentActivities}
                                            displayCount={displayCount}
                                            setDisplayCount={setDisplayCount}
                                            deleteActivity={deleteActivity}
                                        />
                                    ))}
                                </SortableContext>
                            </DndContext>
                        )}
                        {activeTab === 'calendar' && (
                            <Calendar
                                key="calendar"
                                onSelectDate={handleSelectDate}
                                addActivity={addActivity}
                                schedules={calendarSchedules}
                                setSchedules={setCalendarSchedules}
                                showToast={showToast}
                                onRequestDelete={requestCalendarDelete}
                                onOpenAlarm={handleOpenAlarmModal}
                                onOpenEditor={handleOpenCalendarEditor}
                                onOpenDateSelector={() => setIsDateSelectorOpen(true)}
                            />
                        )}
                        {activeTab === 'memo' &&
                            <MemoPage
                                memos={memos}
                                onDeleteMemoRequest={requestDeleteConfirmation}
                                onOpenNewMemo={handleOpenNewMemoFromPage}
                                onOpenDetailMemo={handleOpenDetailMemo}
                                showToast={showToast}
                                isSelectionMode={isSelectionMode}
                                selectedMemoIds={selectedMemoIds}
                                onStartSelectionMode={handleStartSelectionMode}
                                onToggleMemoSelection={handleToggleMemoSelection}
                                onExitSelectionMode={handleExitSelectionMode}
                                onToggleSelectedMemosImportance={handleToggleSelectedMemosImportance}
                                onToggleSelectedMemosStealth={handleToggleSelectedMemosStealth}
                                onRequestDeleteSelectedMemos={requestDeleteSelectedMemos}
                                onUpdateMemoFolder={handleUpdateMemoFolder}
                                onRequestUnshareSelectedMemos={requestUnshareSelectedMemos}
                            />
                        }
                        {activeTab === 'todo' && <div>í•  ì¼ í˜ì´ì§€</div>}
                        {activeTab === 'recent-detail' && <div>ìµœê·¼ í™œë™ ìƒì„¸ í˜ì´ì§€</div>}
                        {activeTab === 'trash' && <TrashPage showToast={showToast} />}
                        {activeTab === 'secret' && (
                            <SecretPage
                                onClose={() => setActiveTab('home')}
                                profile={profile}
                                showToast={showToast}
                                setShowHeader={setShowHeader}
                            />
                        )}
                        {activeTab === 'chat' && <MessagingHub showToast={showToast} memos={memos} />}
                    </ContentArea>

                    <FloatingButton onClick={handleOpenNewMemoFromFAB} activeTab={activeTab} />
                    {activeTab === 'chat' && <AdBanner />}
                    <BottomNav activeTab={activeTab} onSwitchTab={handleSwitchTab} />
                    <SideMenu
                        isOpen={isMenuOpen}
                        onClose={handleToggleMenu}
                        displayCount={displayCount}
                        setDisplayCount={setDisplayCount}
                        showToast={showToast}
                        onOpenMacro={() => {
                            setIsMenuOpen(false);
                            setIsMacroModalOpen(true);
                        }}
                        onOpenFortune={handleOpenFortune}
                        onExport={handleDataExport}
                        onImport={handleDataImport}
                        onRestoreFromDrive={handleRestoreFromDrive}
                        onSync={handleSync}
                        profile={profile}
                        onProfileClick={handleProfileClick}
                        onLogout={handleLogout}
                        onLoginClick={() => setIsLoginModalOpen(true)}
                        onOpenTimer={() => setIsTimerOpen(true)}
                        onOpenTrash={() => {
                            setIsMenuOpen(false);
                            setActiveTab('trash');
                        }}
                        onOpenSecret={() => {
                            setIsMenuOpen(false);
                            setActiveTab('secret');
                        }}
                        onRestoreMemoFolder={handleRestoreMemoFolder}
                        onRoomSelect={handleRoomSelect}
                    />
                </>
            </Screen>
            
            {/* â˜…â˜…â˜… ë¡œê·¸ì¸ ëª¨ë‹¬ ë Œë”ë§ ë¡œì§ â˜…â˜…â˜… */}
            {isLoginModalOpen && (
                <LoginModal
                    onSuccess={handleLoginSuccess}
                    onError={handleLoginError}
                    onClose={() => setIsLoginModalOpen(false)}
                    setProfile={setProfile}
                />
            )}

            {/* ëª¨ë‹¬(Modal)ë“¤ì€ Screen ì»´í¬ë„ŒíŠ¸ ë°”ê¹¥ì— ë‘ì–´ ì „ì²´ í™”ë©´ì„ ë®ë„ë¡ í•©ë‹ˆë‹¤. */}
            {toastMessage && (
                <ToastOverlay>
                    <ToastBox>
                        {toastMessage}
                    </ToastBox>
                </ToastOverlay>
            )}

            {/* ë³µì› í™•ì¸ ëª¨ë‹¬ */}
            {isRestoreConfirmOpen && (
                <ConfirmModal
                    type={restoreType}
                    onConfirm={() => {
                        if (restoreType === 'phone') {
                            executeDataImport();
                        } else {
                            executeGoogleDriveRestore();
                        }
                    }}
                    onCancel={() => {
                        setIsRestoreConfirmOpen(false);
                        setPendingRestoreFile(null);
                    }}
                />
            )}

            {isSearchModalOpen && (
                <SearchModal
                    onClose={() => setIsSearchModalOpen(false)}
                    allData={allData}
                    onSelectResult={(id, type) => {
                        setIsSearchModalOpen(false);
                        console.log(`ì„ íƒëœ í•­ëª©: ID: ${id}, ìœ í˜•: ${type}`);
                    }}
                />
            )}
            {isCalendarEditorOpen && (
                <CalendarEditorModal
                    isOpen={isCalendarEditorOpen}
                    onClose={() => setIsCalendarEditorOpen(false)}
                    data={calendarModalData}
                    onSave={handleCalendarScheduleSave}
                />
            )}
            {isDateSelectorOpen && (
                <DateSelectorModal
                    isOpen={isDateSelectorOpen}
                    onClose={() => setIsDateSelectorOpen(false)}
                    onSelectDate={handleSelectDate}
                />
            )}
            
            <NewMemoModal
                isOpen={isNewMemoModalOpen}
                openSource={memoOpenSource}
                onSave={handleSaveNewMemo}
                onCancel={() => {
                    setIsNewMemoModalOpen(false);
                    setMemoOpenSource(null);
                    setNewMemoFolderId(null); // í´ë” ID ì´ˆê¸°í™”
                }}
            />

            <MemoDetailModal
                isOpen={isDetailModalOpen}
                memo={selectedMemo}
                onSave={handleEditMemo}
                onCancel={() => setIsDetailModalOpen(false)}
                onUpdateMemoFolder={handleUpdateMemoFolder}
                showToast={showToast}
            />
            
            {isDeleteModalOpen && (
                <ConfirmationModal
                    isOpen={true}
                    message={
                        Array.isArray(memoToDelete) 
                            ? `ì„ íƒí•œ ${memoToDelete.length}ê°œì˜ ë©”ëª¨ë¥¼ ì •ë§ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?`
                            : "ë©”ëª¨ë¥¼ ì •ë§ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?"
                    }
                    onConfirm={handleDeleteConfirm}
                    onCancel={handleDeleteCancel}
                />
            )}

            {isCalendarConfirmOpen && dateToDelete && (
                <ConfirmationModal
                    isOpen={true}
                    message={
                        <>
                            {`${format(dateToDelete, '<yyyyë…„ Mì›” dì¼>ì˜', { locale: ko })}`} ìŠ¤ì¼€ì¤„ì„
                            <br />
                            ì •ë§ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?
                        </>
                    }
                    onConfirm={executeCalendarDelete}
                    onCancel={() => setIsCalendarConfirmOpen(false)}
                />
            )}

            {isUnshareConfirmOpen && (
                <ConfirmModal
                    title="ê³µìœ  í•´ì œ"
                    message={`ì„ íƒí•œ ${selectedMemoIds.size}ê°œì˜ ë¬¸ì„œ ê³µìœ ë¥¼ í•´ì œ í• ê¹Œìš”?\n\ní•´ì œì‹œ í•´ë‹¹ë¬¸ì„œì™€ ì—°ê³„ëœ ëŒ€í™”ë°©ì€\nì‚­ì œë˜ë©° ë¬¸ì„œëŠ” ì›ë˜ í´ë”ë¡œ ë³µì›ë©ë‹ˆë‹¤.`}
                    onConfirm={executeUnshareSelectedMemos}
                    onCancel={() => setIsUnshareConfirmOpen(false)}
                />
            )}
            <AlarmModal
                isOpen={isAlarmModalOpen}
                scheduleData={scheduleForAlarm}
                onSave={handleSaveAlarm}
                onClose={() => setIsAlarmModalOpen(false)}
            />
            {/* âš™ï¸ ë§¤í¬ë¡œ ëª¨ë‹¬ */}
            {isMacroModalOpen && (
                <MacroModal onClose={() => setIsMacroModalOpen(false)} />
            )}
            {/* âœ¨ ğŸ”® ì˜¤ëŠ˜ì˜ ìš´ì„¸ ì „ì²´ í”Œë¡œìš° ì»´í¬ë„ŒíŠ¸ */}
            {isFortuneFlowOpen && (
                <FortuneFlow
                    onClose={() => setIsFortuneFlowOpen(false)}
                    profile={profile}
                    // ìš´ì„¸ ê²°ê³¼ ë° ê¸°íƒ€ ìƒíƒœë¥¼ FortuneFlow ë‚´ë¶€ì—ì„œ ê´€ë¦¬
                />
            )}

            {/* â±ï¸ íƒ€ì´ë¨¸ ëª¨ë‹¬ */}
            {isTimerOpen && (
                <Timer onClose={() => setIsTimerOpen(false)} />
            )}

            {/* ğŸ  í˜‘ì—…ë°© ëª¨ë‹¬ */}
            {isCollaborationRoomOpen && selectedRoomId && (
                <CollaborationRoom
                    roomId={selectedRoomId}
                    onClose={handleCloseCollaborationRoom}
                />
            )}

            {/* ğŸ‘¤ í”„ë¡œí•„ í˜ì´ì§€ ëª¨ë‹¬ */}
            {activeTab === 'profile' && (
                <ProfilePage
                    profile={profile}
                    memos={memos}
                    calendarSchedules={calendarSchedules}
                    showToast={showToast}
                    onClose={() => setActiveTab('home')}
                />
            )}

            {/* â° ì•ŒëŒ ì•Œë¦¼ */}
            {currentAlarm && (
                <AlarmNotification
                    isVisible={true}
                    scheduleData={currentAlarm.scheduleData}
                    onDismiss={() => dismissAlarm(handleAlarmDismissed)}
                    onSnooze={snoozeAlarm}
                    currentSnoozeCount={currentAlarm.snoozeCount || 0}
                    maxSnoozeCount={3}
                />
            )}

            </AppContent>
        </TrashProvider>
        </AppRouter>
    );
}

export default App;